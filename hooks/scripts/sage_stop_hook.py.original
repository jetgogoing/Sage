#!/usr/bin/env python3
"""
Sage Stop Hook - 统一会话结束处理脚本
整合所有归档和会话结束功能的重量级完整解决方案

功能整合:
- sage_archiver.py: 安全验证 + 双重备份策略
- sage_stop_hook.py: 工具调用处理 + 元数据增强  
- sage_stop_hook_simple.py: 会话工具调用聚合
- sage_stop_hook_lightweight.py: 基础文本处理

设计原则:
- 重量级架构，功能完整性优先
- 支持多种输入格式自动检测
- 最高安全级别验证
- 数据库+本地双重保障
"""

import json
import sys
import subprocess
import logging
import time
import os
import hashlib
import asyncio
import uuid
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Union

# 导入HookExecutionContext
sys.path.insert(0, str(Path(__file__).parent.parent))
from context import create_hook_context

# 导入完整安全验证工具
try:
    from security_utils import InputValidator, PathValidator, ResourceLimiter, SecurityError
    security_available = True
except ImportError:
    security_available = False
    print("Warning: Full security validation not available, using basic validation")

# 导入数据聚合器
try:
    from hook_data_aggregator import HookDataAggregator
    aggregator_available = True
except ImportError:
    aggregator_available = False

# 文件锁机制
try:
    from file_lock import JsonFileLock
    file_lock_available = True
except ImportError:
    file_lock_available = False

class SageStopHook:
    """统一的Sage会话结束处理器"""
    
    def __init__(self):
        # 使用HookExecutionContext统一架构
        self.context = create_hook_context(__file__)
        self.logger = self.context.setup_logging('SageStopHook', 'sage_stop_hook.log')
        
        # 安全验证器
        if security_available:
            self.input_validator = InputValidator()
            self.path_validator = PathValidator()
            self.resource_limiter = ResourceLimiter()
        else:
            self.input_validator = None
            self.path_validator = None
            self.resource_limiter = None
            
        # 数据聚合器
        if aggregator_available:
            self.aggregator = HookDataAggregator()
        else:
            self.aggregator = None
            
        # 输出目录
        self.output_dir = self.context.get_backup_dir()
        self.temp_dir = Path.home() / '.sage_hooks_temp'
        self.temp_dir.mkdir(exist_ok=True)
        
        self.logger.info("Sage Stop Hook initialized with unified architecture")
    
    def parse_input(self) -> Dict[str, Any]:
        """解析并验证输入数据"""
        try:
            input_text = sys.stdin.read().strip()
            if not input_text:
                self.logger.error("No input provided")
                return {}
            
            # 尝试解析JSON输入
            try:
                input_data = json.loads(input_text)
                if isinstance(input_data, dict):
                    return self._validate_json_input(input_data)
            except json.JSONDecodeError:
                pass
            
            # 处理纯文本输入（Human:/Assistant:格式）
            return self._parse_text_input(input_text)
            
        except Exception as e:
            self.logger.error(f"Failed to parse input: {e}")
            return {}
    
    def _validate_json_input(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """验证JSON格式输入"""
        if self.input_validator:
            try:
                # 验证session_id
                session_id = input_data.get('session_id', '')
                if session_id:
                    self.input_validator.validate_session_id(session_id)
                
                # 验证文件路径
                transcript_path = input_data.get('transcript_path', '')
                if transcript_path:
                    validated_path = self.path_validator.validate_transcript_path(transcript_path)
                    if validated_path:
                        input_data['transcript_path'] = validated_path
                
                self.logger.info(f"JSON input validated: session_id={session_id}")
                return input_data
                
            except Exception as e:
                self.logger.error(f"JSON input validation failed: {e}")
                return {}
        else:
            # 基本验证
            if len(str(input_data)) > 100000:  # 100KB限制
                self.logger.error("Input data too large")
                return {}
            return input_data
    
    def _parse_text_input(self, text: str) -> Dict[str, Any]:
        """解析Human:/Assistant:格式的文本输入"""
        if self.input_validator:
            try:
                clean_text = self.input_validator.sanitize_string(text, max_length=50000)
            except Exception as e:
                self.logger.error(f"Text sanitization failed: {e}")
                return {}
        else:
            clean_text = text[:50000]  # 基本长度限制
        
        self.logger.info(f"Text input parsed: {len(clean_text)} characters")
        return {
            'format': 'text',
            'content': clean_text,
            'session_id': f"text-session-{int(time.time())}"
        }
    
    def detect_input_format(self, input_data: Dict[str, Any]) -> str:
        """检测输入数据格式"""
        if 'transcript_path' in input_data and input_data['transcript_path']:
            return 'claude_cli_jsonl'
        elif 'format' in input_data and input_data['format'] == 'text':
            return 'human_assistant_text'
        elif 'content' in input_data:
            return 'human_assistant_text'
        else:
            return 'unknown'
    
    def process_claude_cli_jsonl(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """处理Claude CLI的transcript.jsonl文件"""
        transcript_path = input_data.get('transcript_path', '')
        if not transcript_path or not os.path.exists(transcript_path):
            self.logger.error(f"Transcript file not found: {transcript_path}")
            return {}
        
        try:
            # 安全读取文件
            if self.resource_limiter:
                self.resource_limiter.limit_file_operations(transcript_path, max_size=100*1024*1024)
                lines = self.resource_limiter.safe_read_lines(transcript_path, max_lines=10000)
            else:
                with open(transcript_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
            
            # 提取完整交互数据
            conversation_data = self._extract_complete_interaction(lines)
            
            # 调试信息：输出提取到的消息数量和类型
            messages = conversation_data.get('messages', [])
            self.logger.info(f"Extracted {len(messages)} messages")
            for i, msg in enumerate(messages[:3]):  # 只显示前3条
                self.logger.info(f"Message {i}: role={msg.get('role')}, content_len={len(msg.get('content', ''))}")
            
            # 增强元数据
            conversation_data.update({
                'session_id': input_data.get('session_id', ''),
                'transcript_path': str(transcript_path),
                'project_id': self.get_project_id(),
                'project_name': os.path.basename(os.getcwd()),
                'processing_timestamp': time.time(),
                'format': 'claude_cli_jsonl'
            })
            
            return conversation_data
            
        except Exception as e:
            self.logger.error(f"Failed to process Claude CLI JSONL: {e}")
            return {}
    
    def _extract_complete_interaction(self, lines: List[str]) -> Dict[str, Any]:
        """从JSONL行中提取完整的交互数据（包含工具调用）"""
        messages = []
        tool_calls = []
        
        # 从后往前解析，获取最近的交互
        for line in reversed(lines[-50:]):  # 检查最后50行
            if not line.strip():
                continue
                
            try:
                entry = json.loads(line.strip())
                entry_type = entry.get('type', '')
                
                if entry_type in ['user', 'assistant']:
                    message_data = self._parse_claude_cli_message(entry)
                    if message_data:
                        messages.insert(0, message_data)
                        
                        # 提取工具调用信息
                        if entry_type == 'assistant':
                            tool_info = self._extract_tool_calls_from_message(entry)
                            if tool_info:
                                tool_calls.extend(tool_info)
                                
            except json.JSONDecodeError:
                continue
        
        return {
            'messages': messages,
            'tool_calls': tool_calls,
            'message_count': len(messages),
            'tool_call_count': len(tool_calls),
            'extraction_method': 'claude_cli_jsonl'
        }
    
    def _parse_claude_cli_message(self, entry: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """解析Claude CLI消息格式"""
        message = entry.get('message', {})
        content_list = message.get('content', [])
        
        content_parts = []
        for item in content_list:
            if isinstance(item, dict):
                if item.get('type') == 'text':
                    content_parts.append(item.get('text', ''))
                elif item.get('type') == 'thinking':
                    thinking_content = item.get('thinking', '')
                    content_parts.append(f"[思维链]\n{thinking_content}")
                elif item.get('type') == 'tool_use':
                    tool_name = item.get('name', 'unknown_tool')
                    content_parts.append(f"[工具调用: {tool_name}]")
            elif isinstance(item, str):
                content_parts.append(item)
        
        if content_parts:
            return {
                'role': entry.get('type'),
                'content': '\n'.join(content_parts),
                'timestamp': entry.get('timestamp'),
                'uuid': entry.get('uuid')
            }
        return None
    
    def _extract_tool_calls_from_message(self, entry: Dict[str, Any]) -> List[Dict[str, Any]]:
        """从助手消息中提取工具调用信息"""
        message = entry.get('message', {})
        content_list = message.get('content', [])
        tool_calls = []
        
        for item in content_list:
            if isinstance(item, dict) and item.get('type') == 'tool_use':
                tool_calls.append({
                    'tool_name': item.get('name', 'unknown'),
                    'tool_input': item.get('input', {}),
                    'call_id': item.get('id', ''),
                    'timestamp': entry.get('timestamp'),
                    'message_uuid': entry.get('uuid')
                })
        
        return tool_calls
    
    def process_human_assistant_text(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """处理Human:/Assistant:格式的文本"""
        content = input_data.get('content', '')
        if not content:
            return {}
        
        try:
            # 解析Human/Assistant对话
            messages = self._parse_human_assistant_format(content)
            
            # 聚合当前会话的工具调用数据
            tool_calls = []
            if self.aggregator:
                try:
                    session_data = self.aggregator.aggregate_current_session()
                    tool_calls = session_data.get('tool_calls', [])
                    self.logger.info(f"Aggregated {len(tool_calls)} tool calls from session")
                except Exception as e:
                    self.logger.warning(f"Failed to aggregate tool calls: {e}")
            
            return {
                'messages': messages,
                'tool_calls': tool_calls,
                'message_count': len(messages),
                'tool_call_count': len(tool_calls),
                'session_id': input_data.get('session_id', ''),
                'project_id': self.get_project_id(),
                'project_name': os.path.basename(os.getcwd()),
                'processing_timestamp': time.time(),
                'format': 'human_assistant_text',
                'extraction_method': 'text_parsing_with_aggregation'
            }
            
        except Exception as e:
            self.logger.error(f"Failed to process Human/Assistant text: {e}")
            return {}
    
    def _parse_human_assistant_format(self, content: str) -> List[Dict[str, Any]]:
        """解析Human:/Assistant:格式文本"""
        messages = []
        current_role = None
        current_content = []
        
        lines = content.split('\n')
        for line in lines:
            line = line.strip()
            if line.startswith('Human:'):
                if current_role and current_content:
                    messages.append({
                        'role': current_role,
                        'content': '\n'.join(current_content).strip(),
                        'timestamp': time.time()
                    })
                current_role = 'user'
                current_content = [line[6:].strip()]  # Remove 'Human:' prefix
            elif line.startswith('Assistant:'):
                if current_role and current_content:
                    messages.append({
                        'role': current_role,
                        'content': '\n'.join(current_content).strip(),
                        'timestamp': time.time()
                    })
                current_role = 'assistant'
                current_content = [line[10:].strip()]  # Remove 'Assistant:' prefix
            else:
                if current_role:
                    current_content.append(line)
        
        # 添加最后一条消息
        if current_role and current_content:
            messages.append({
                'role': current_role,
                'content': '\n'.join(current_content).strip(),
                'timestamp': time.time()
            })
        
        return messages
    
    def get_project_id(self) -> str:
        """生成项目唯一标识"""
        project_path = os.getcwd()
        return hashlib.md5(project_path.encode()).hexdigest()[:12]
    
    def save_to_database(self, conversation_data: Dict[str, Any]) -> bool:
        """保存数据到Sage Core数据库"""
        try:
            self.logger.info("Initializing Sage Core for database save...")
            start_time = time.time()
            
            # 使用上下文设置Python路径
            self.context.setup_python_path()
            
            # 获取配置
            sage_config = self.context.get_sage_config()
            
            # 导入Sage Core - 使用正确的导入路径
            from sage_core.singleton_manager import get_sage_core
            from sage_core.interfaces.core_service import MemoryContent
            
            # 构建消息内容
            messages = conversation_data.get('messages', [])
            if not messages:
                self.logger.warning("No messages to save")
                return False
            
            # 提取用户输入和助手响应
            user_input = ""
            assistant_response = ""
            
            for msg in messages:
                if msg.get('role') == 'user':
                    user_input = msg.get('content', '')
                elif msg.get('role') == 'assistant':
                    assistant_response = msg.get('content', '')
            
            if not user_input or not assistant_response:
                self.logger.warning("Missing user input or assistant response")
                return False
            
            # 构建元数据
            metadata = {
                'session_id': conversation_data.get('session_id', ''),
                'project_id': conversation_data.get('project_id', ''),
                'project_name': conversation_data.get('project_name', ''),
                'format': conversation_data.get('format', ''),
                'extraction_method': conversation_data.get('extraction_method', ''),
                'processing_timestamp': conversation_data.get('processing_timestamp', time.time()),
                'message_count': conversation_data.get('message_count', 0),
                'tool_call_count': conversation_data.get('tool_call_count', 0),
                'tool_calls': conversation_data.get('tool_calls', [])
            }
            
            # 异步保存函数
            async def save_to_sage_core():
                sage = await get_sage_core()
                await sage.initialize(sage_config)
                
                # 构建MemoryContent对象
                content = MemoryContent(
                    user_input=user_input,
                    assistant_response=assistant_response,
                    metadata=metadata,
                    session_id=metadata.get('session_id')
                )
                
                # 保存到数据库并向量化
                memory_id = await sage.save_memory(content)
                return memory_id is not None and memory_id != ""
            
            # 运行异步调用
            try:
                # 检查是否存在运行中的事件循环
                try:
                    loop = asyncio.get_running_loop()
                    loop_running = True
                except RuntimeError:
                    loop_running = False
                
                if loop_running:
                    # 如果已经在事件循环中，创建新任务
                    import concurrent.futures
                    with concurrent.futures.ThreadPoolExecutor() as executor:
                        future = executor.submit(asyncio.run, save_to_sage_core())
                        result = future.result(timeout=30)
                        elapsed_time = time.time() - start_time
                        self.logger.info(f"Database save completed in {elapsed_time:.2f}s")
                        return result
                else:
                    # 如果没有运行的事件循环，直接运行
                    result = asyncio.run(save_to_sage_core())
                    elapsed_time = time.time() - start_time
                    self.logger.info(f"Database save completed in {elapsed_time:.2f}s")
                    return result
            except Exception as e:
                self.logger.error(f"Async database save failed: {e}")
                return False
            
        except Exception as e:
            self.logger.error(f"Database save failed: {e}")
            return False
    
    def save_local_backup(self, conversation_data: Dict[str, Any]) -> bool:
        """保存本地备份文件"""
        try:
            timestamp = int(time.time())
            session_id = conversation_data.get('session_id', 'unknown')
            filename = f"conversation_{session_id}_{timestamp}.json"
            backup_path = self.output_dir / filename
            
            # 准备备份数据
            backup_data = {
                'backup_timestamp': timestamp,
                'backup_version': 'sage_stop_hook_v2.03',
                'conversation_data': conversation_data,
                'system_info': {
                    'cwd': os.getcwd(),
                    'python_version': sys.version,
                    'platform': os.name
                }
            }
            
            # 写入备份文件
            if file_lock_available:
                json_lock = JsonFileLock(backup_path)
                success = json_lock.safe_write(backup_data)
            else:
                with open(backup_path, 'w', encoding='utf-8') as f:
                    json.dump(backup_data, f, indent=2, ensure_ascii=False)
                success = True
            
            if success:
                self.logger.info(f"Local backup saved: {backup_path}")
                return True
            else:
                self.logger.error(f"Failed to save local backup: {backup_path}")
                return False
                
        except Exception as e:
            self.logger.error(f"Local backup failed: {e}")
            return False
    
    def cleanup_temp_files(self):
        """清理临时文件"""
        try:
            if not self.temp_dir.exists():
                return
            
            cutoff_time = time.time() - 3600  # 1小时前的文件
            cleaned_count = 0
            
            for temp_file in self.temp_dir.glob("*.json"):
                try:
                    if temp_file.stat().st_mtime < cutoff_time:
                        temp_file.unlink()
                        cleaned_count += 1
                except Exception as e:
                    self.logger.warning(f"Failed to clean temp file {temp_file}: {e}")
            
            if cleaned_count > 0:
                self.logger.info(f"Cleaned {cleaned_count} temporary files")
                
        except Exception as e:
            self.logger.warning(f"Temp file cleanup failed: {e}")
    
    def run(self) -> None:
        """主运行逻辑"""
        start_time = time.time()
        
        try:
            # 解析输入
            input_data = self.parse_input()
            if not input_data:
                self.logger.error("No valid input data")
                sys.exit(1)
            
            # 检测输入格式并处理
            input_format = self.detect_input_format(input_data)
            self.logger.info(f"Detected input format: {input_format}")
            
            if input_format == 'claude_cli_jsonl':
                conversation_data = self.process_claude_cli_jsonl(input_data)
            elif input_format == 'human_assistant_text':
                conversation_data = self.process_human_assistant_text(input_data)
            else:
                self.logger.error(f"Unsupported input format: {input_format}")
                sys.exit(1)
            
            if not conversation_data:
                self.logger.error("Failed to process conversation data")
                sys.exit(1)
            
            # 保存到数据库（主要策略）
            db_success = self.save_to_database(conversation_data)
            
            # 保存本地备份（保障策略）
            backup_success = self.save_local_backup(conversation_data)
            
            # 清理临时文件
            self.cleanup_temp_files()
            
            # 执行结果
            elapsed_time = time.time() - start_time
            
            if db_success:
                self.logger.info(f"Conversation archived successfully in {elapsed_time:.2f}s")
                print(f"SUCCESS: Conversation archived (DB: {db_success}, Backup: {backup_success})")
            elif backup_success:
                self.logger.info(f"Conversation backup saved (DB failed) in {elapsed_time:.2f}s")
                print(f"PARTIAL: Backup saved, database failed")
            else:
                self.logger.error(f"All save methods failed in {elapsed_time:.2f}s")
                sys.exit(1)
                
        except Exception as e:
            self.logger.error(f"Unexpected error in main execution: {e}")
            sys.exit(1)


def main():
    """入口函数"""
    hook = SageStopHook()
    hook.run()


if __name__ == "__main__":
    main()