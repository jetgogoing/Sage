æˆ‘ï¼šclaude codeçš„ MCP é€šè®¯è§„æ ¼ï¼Œæ ‡å‡†ï¼Œåˆ°åº•æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿè¦å¦‚ä½•æ‰èƒ½é¡ºåˆ©çš„æŠŠæˆ‘å¼€å‘çš„é¡¹ç›®ä¸claude codeè¿æ¥èµ·æ¥ï¼Ÿ


æˆ‘æ¥ä¸ºæ‚¨è¯¦ç»†ä»‹ç» MCP (Model Context Protocol) çš„é€šè®¯è§„æ ¼å’Œå¦‚ä½•å°†æ‚¨çš„é¡¹ç›®ä¸ Claude Code è¿æ¥ã€‚

## MCP æ˜¯ä»€ä¹ˆï¼Ÿ

MCP æ˜¯ Anthropic å¼€å‘çš„å¼€æ”¾åè®®ï¼Œç”¨äºå®ç° AI åŠ©æ‰‹ï¼ˆå¦‚ Claudeï¼‰ä¸å¤–éƒ¨æ•°æ®æºå’Œå·¥å…·ä¹‹é—´çš„æ— ç¼é›†æˆã€‚å®ƒæä¾›äº†ä¸€ä¸ªæ ‡å‡†åŒ–çš„æ–¹å¼æ¥æš´éœ²ä¸Šä¸‹æ–‡ã€èµ„æºå’Œå·¥å…·ç»™ AI æ¨¡å‹ã€‚

## MCP çš„æ ¸å¿ƒç»„ä»¶

### 1. **æœåŠ¡å™¨ï¼ˆMCP Serverï¼‰**
- æš´éœ²èµ„æºï¼ˆresourcesï¼‰ã€å·¥å…·ï¼ˆtoolsï¼‰å’Œæç¤ºï¼ˆpromptsï¼‰
- å¯ä»¥ç”¨ TypeScript/JavaScript æˆ– Python å®ç°
- é€šè¿‡æ ‡å‡†è¾“å…¥/è¾“å‡ºï¼ˆstdioï¼‰æˆ– HTTP è¿›è¡Œé€šä¿¡

### 2. **å®¢æˆ·ç«¯ï¼ˆMCP Clientï¼‰**
- Claude Code å°±æ˜¯ä¸€ä¸ª MCP å®¢æˆ·ç«¯
- è¿æ¥åˆ° MCP æœåŠ¡å™¨å¹¶ä½¿ç”¨å…¶æä¾›çš„åŠŸèƒ½

### 3. **ä¼ è¾“å±‚ï¼ˆTransportï¼‰**
- æ”¯æŒ stdioï¼ˆæ ‡å‡†è¾“å…¥è¾“å‡ºï¼‰
- æ”¯æŒ HTTP/SSEï¼ˆæœåŠ¡å™¨å‘é€äº‹ä»¶ï¼‰

## é€šè®¯åè®®è§„æ ¼

MCP ä½¿ç”¨ JSON-RPC 2.0 ä½œä¸ºæ¶ˆæ¯æ ¼å¼ï¼š

```json
// è¯·æ±‚ç¤ºä¾‹
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "tools/list",
  "params": {}
}

// å“åº”ç¤ºä¾‹
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "tools": [
      {
        "name": "search",
        "description": "Search for information",
        "inputSchema": {
          "type": "object",
          "properties": {
            "query": {"type": "string"}
          }
        }
      }
    ]
  }
}
```

## å¦‚ä½•å¼€å‘ MCP æœåŠ¡å™¨

### ä½¿ç”¨ TypeScript/JavaScriptï¼š

```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const server = new Server({
  name: 'my-mcp-server',
  version: '1.0.0',
}, {
  capabilities: {
    tools: {},
    resources: {}
  }
});

// å®šä¹‰å·¥å…·
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [{
      name: 'my_tool',
      description: 'My custom tool',
      inputSchema: {
        type: 'object',
        properties: {
          input: { type: 'string' }
        },
        required: ['input']
      }
    }]
  };
});

// å¤„ç†å·¥å…·è°ƒç”¨
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  if (request.params.name === 'my_tool') {
    // å®ç°æ‚¨çš„é€»è¾‘
    return {
      content: [{
        type: 'text',
        text: `å¤„ç†ç»“æœ: ${request.params.arguments.input}`
      }]
    };
  }
});

// å¯åŠ¨æœåŠ¡å™¨
const transport = new StdioServerTransport();
await server.connect(transport);
```

### ä½¿ç”¨ Pythonï¼š

```python
from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializationOptions
import mcp.server.stdio
import mcp.types as types

server = Server("my-mcp-server")

@server.list_tools()
async def handle_list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="my_tool",
            description="My custom tool",
            inputSchema={
                "type": "object",
                "properties": {
                    "input": {"type": "string"}
                },
                "required": ["input"]
            }
        )
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    if name == "my_tool":
        return [types.TextContent(
            type="text",
            text=f"å¤„ç†ç»“æœ: {arguments['input']}"
        )]

# å¯åŠ¨æœåŠ¡å™¨
async def main():
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            InitializationOptions()
        )
```

## é…ç½® Claude Code è¿æ¥

åœ¨ Claude Code çš„é…ç½®æ–‡ä»¶ï¼ˆé€šå¸¸æ˜¯ `claude_desktop_config.json`ï¼‰ä¸­æ·»åŠ æ‚¨çš„ MCP æœåŠ¡å™¨ï¼š

```json
{
  "mcpServers": {
    "my-server": {
      "command": "node",
      "args": ["path/to/your/server.js"],
      "env": {
        "API_KEY": "your-api-key"
      }
    }
  }
}
```

å¯¹äº Python æœåŠ¡å™¨ï¼š
```json
{
  "mcpServers": {
    "my-server": {
      "command": "python",
      "args": ["-m", "your_module"],
      "env": {
        "PYTHONPATH": "/path/to/your/project"
      }
    }
  }
}
```

## æœ€ä½³å®è·µ

1. **é”™è¯¯å¤„ç†**ï¼šå§‹ç»ˆå®ç°å¥å£®çš„é”™è¯¯å¤„ç†
2. **è¾“å…¥éªŒè¯**ï¼šéªŒè¯æ‰€æœ‰è¾“å…¥å‚æ•°
3. **æ—¥å¿—è®°å½•**ï¼šä½¿ç”¨æ ‡å‡†é”™è¯¯è¾“å‡ºï¼ˆstderrï¼‰è¿›è¡Œæ—¥å¿—è®°å½•
4. **èµ„æºç®¡ç†**ï¼šæ­£ç¡®ç®¡ç†è¿æ¥å’Œèµ„æº
5. **å¼‚æ­¥æ“ä½œ**ï¼šå¯¹äºé•¿æ—¶é—´è¿è¡Œçš„æ“ä½œä½¿ç”¨å¼‚æ­¥å¤„ç†

## è°ƒè¯•æŠ€å·§

1. ä½¿ç”¨ MCP Inspector å·¥å…·æµ‹è¯•æ‚¨çš„æœåŠ¡å™¨
2. æŸ¥çœ‹ Claude Code çš„æ—¥å¿—æ–‡ä»¶
3. åœ¨æœåŠ¡å™¨ä¸­æ·»åŠ è¯¦ç»†çš„æ—¥å¿—è¾“å‡º
4. ä½¿ç”¨ç¯å¢ƒå˜é‡æ§åˆ¶è°ƒè¯•çº§åˆ«

è¦äº†è§£æ›´å¤šè¯¦ç»†ä¿¡æ¯å’Œå®Œæ•´çš„ API æ–‡æ¡£ï¼Œå»ºè®®æ‚¨è®¿é—® Anthropic çš„å®˜æ–¹æ–‡æ¡£ç½‘ç«™ã€‚å¦‚æœæ‚¨åœ¨å®ç°è¿‡ç¨‹ä¸­é‡åˆ°å…·ä½“é—®é¢˜ï¼Œæˆ‘å¾ˆä¹æ„å¸®åŠ©æ‚¨è§£å†³ï¼


æˆ‘ï¼š
é˜…è¯»ï¼š
api-reference.mdå’Œreadme.md
æˆ‘çš„è®¾è®¡å¯¹å—ï¼Ÿæˆ‘çš„é¡¹ç›®ä¸€ç›´æ— æ³•ä¸Claude codeè¿æ¥



çœ‹äº†æ‚¨çš„é¡¹ç›®æ–‡æ¡£ï¼Œæ‚¨çš„è®¾è®¡æ€è·¯æ˜¯æ­£ç¡®çš„ï¼Œä½†åœ¨å®ç°ä¸Šæœ‰ä¸€äº›å…³é”®é—®é¢˜éœ€è¦è§£å†³ã€‚è®©æˆ‘å¸®æ‚¨åˆ†æä¸ºä»€ä¹ˆæ— æ³•ä¸ Claude Code è¿æ¥ï¼Œå¹¶æä¾›è§£å†³æ–¹æ¡ˆã€‚

## ä¸»è¦é—®é¢˜åˆ†æ

### 1. **MCP é…ç½®æ ¼å¼é”™è¯¯**

æ‚¨åœ¨æ–‡æ¡£ä¸­æåˆ°çš„ Claude Code é…ç½®ï¼š
```json
{
  "mcpServers": {
    "sage": {
      "type": "http",  // âŒ è¿™ä¸æ˜¯æœ‰æ•ˆçš„é…ç½®
      "url": "http://localhost:17800/mcp"
    }
  }
}
```

**æ­£ç¡®çš„é…ç½®åº”è¯¥æ˜¯ï¼š**
```json
{
  "mcpServers": {
    "sage": {
      "command": "python",
      "args": ["-m", "uvicorn", "app.sage_mcp_server:app", "--host", "0.0.0.0", "--port", "17800"],
      "env": {
        "SILICONFLOW_API_KEY": "your-api-key",
        "DATABASE_URL": "postgresql://mem:mem@localhost:5432/mem"
      }
    }
  }
}
```

### 2. **MCP over HTTP çš„è¯¯è§£**

MCP åè®®ä¸»è¦é€šè¿‡ **stdioï¼ˆæ ‡å‡†è¾“å…¥è¾“å‡ºï¼‰** é€šä¿¡ï¼Œè€Œä¸æ˜¯ HTTPã€‚è™½ç„¶æ‚¨å®ç°äº† HTTP æœåŠ¡å™¨ï¼Œä½† Claude Code æœŸæœ›çš„æ˜¯ stdio é€šä¿¡ã€‚

### 3. **æ­£ç¡®çš„ MCP æœåŠ¡å™¨å®ç°**

åˆ›å»ºä¸€ä¸ªæ–°æ–‡ä»¶ `app/sage_mcp_stdio_server.py`ï¼š

```python
#!/usr/bin/env python3
import asyncio
import json
import sys
from typing import Any, Dict, List

from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializationOptions
import mcp.server.stdio
import mcp.types as types

from memory_adapter_v2 import MemoryAdapterV2
from intelligent_retrieval import IntelligentRetrieval

# åˆå§‹åŒ–ç»„ä»¶
memory_adapter = MemoryAdapterV2()
retrieval_engine = IntelligentRetrieval(memory_adapter)

# åˆ›å»º MCP æœåŠ¡å™¨
server = Server("sage-memory")

@server.list_tools()
async def handle_list_tools() -> list[types.Tool]:
    """åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„å·¥å…·"""
    return [
        types.Tool(
            name="save_conversation",
            description="ä¿å­˜å¯¹è¯åˆ°è®°å¿†ç³»ç»Ÿ",
            inputSchema={
                "type": "object",
                "properties": {
                    "user_prompt": {
                        "type": "string",
                        "description": "ç”¨æˆ·çš„æé—®"
                    },
                    "assistant_response": {
                        "type": "string", 
                        "description": "åŠ©æ‰‹çš„å›å¤"
                    },
                    "metadata": {
                        "type": "object",
                        "description": "é¢å¤–çš„å…ƒæ•°æ®",
                        "properties": {}
                    }
                },
                "required": ["user_prompt", "assistant_response"]
            }
        ),
        types.Tool(
            name="get_context",
            description="è·å–ä¸æŸ¥è¯¢ç›¸å…³çš„å†å²ä¸Šä¸‹æ–‡",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "æŸ¥è¯¢æ–‡æœ¬"
                    },
                    "max_results": {
                        "type": "integer",
                        "description": "æœ€å¤§ç»“æœæ•°",
                        "default": 5
                    },
                    "strategy": {
                        "type": "string",
                        "description": "æ£€ç´¢ç­–ç•¥",
                        "enum": ["HYBRID_ADVANCED", "AGGRESSIVE", "CONSERVATIVE"],
                        "default": "HYBRID_ADVANCED"
                    }
                },
                "required": ["query"]
            }
        ),
        types.Tool(
            name="search_memory",
            description="æœç´¢è®°å¿†åº“ä¸­çš„ç‰¹å®šå†…å®¹",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "æœç´¢æŸ¥è¯¢"
                    },
                    "n": {
                        "type": "integer",
                        "description": "è¿”å›ç»“æœæ•°",
                        "default": 5
                    },
                    "threshold": {
                        "type": "number",
                        "description": "ç›¸ä¼¼åº¦é˜ˆå€¼",
                        "default": 0.5
                    }
                },
                "required": ["query"]
            }
        ),
        types.Tool(
            name="get_memory_stats",
            description="è·å–è®°å¿†ç³»ç»Ÿç»Ÿè®¡ä¿¡æ¯",
            inputSchema={
                "type": "object",
                "properties": {}
            }
        )
    ]

@server.call_tool()
async def handle_call_tool(
    name: str, 
    arguments: dict
) -> list[types.TextContent]:
    """å¤„ç†å·¥å…·è°ƒç”¨"""
    
    try:
        if name == "save_conversation":
            # ä¿å­˜å¯¹è¯
            success = memory_adapter.add_conversation(
                user_content=arguments["user_prompt"],
                assistant_content=arguments["assistant_response"],
                metadata=arguments.get("metadata", {})
            )
            
            return [types.TextContent(
                type="text",
                text=f"å¯¹è¯å·²ä¿å­˜ã€‚å½“å‰ä¼šè¯ID: {memory_adapter.current_session_id}"
            )]
            
        elif name == "get_context":
            # è·å–ä¸Šä¸‹æ–‡
            context = retrieval_engine.retrieve_contextual(
                query=arguments["query"],
                max_results=arguments.get("max_results", 5),
                strategy=arguments.get("strategy", "HYBRID_ADVANCED")
            )
            
            return [types.TextContent(
                type="text",
                text=json.dumps(context, ensure_ascii=False, indent=2)
            )]
            
        elif name == "search_memory":
            # æœç´¢è®°å¿†
            results = memory_adapter.search(
                query=arguments["query"],
                n=arguments.get("n", 5),
                threshold=arguments.get("threshold", 0.5)
            )
            
            formatted_results = []
            for r in results:
                formatted_results.append({
                    "content": r["content"],
                    "role": r["role"],
                    "score": r["score"],
                    "metadata": r.get("metadata", {})
                })
            
            return [types.TextContent(
                type="text",
                text=json.dumps(formatted_results, ensure_ascii=False, indent=2)
            )]
            
        elif name == "get_memory_stats":
            # è·å–ç»Ÿè®¡ä¿¡æ¯
            stats = memory_adapter.get_stats()
            
            return [types.TextContent(
                type="text",
                text=json.dumps(stats, ensure_ascii=False, indent=2)
            )]
            
        else:
            return [types.TextContent(
                type="text",
                text=f"æœªçŸ¥çš„å·¥å…·: {name}"
            )]
            
    except Exception as e:
        return [types.TextContent(
            type="text",
            text=f"é”™è¯¯: {str(e)}"
        )]

@server.list_prompts()
async def handle_list_prompts() -> list[types.Prompt]:
    """æä¾›è‡ªåŠ¨ä¸Šä¸‹æ–‡æ³¨å…¥çš„ prompt"""
    return [
        types.Prompt(
            name="auto_context",
            description="è‡ªåŠ¨ä¸ºæŸ¥è¯¢æ³¨å…¥ç›¸å…³å†å²ä¸Šä¸‹æ–‡",
            arguments=[
                types.PromptArgument(
                    name="query",
                    description="ç”¨æˆ·çš„æŸ¥è¯¢",
                    required=True
                )
            ]
        )
    ]

@server.get_prompt()
async def handle_get_prompt(
    name: str,
    arguments: dict
) -> types.GetPromptResult:
    """ç”Ÿæˆå¸¦æœ‰å†å²ä¸Šä¸‹æ–‡çš„ prompt"""
    
    if name == "auto_context":
        query = arguments.get("query", "")
        
        # è·å–ç›¸å…³ä¸Šä¸‹æ–‡
        context = retrieval_engine.retrieve_contextual(
            query=query,
            max_results=5,
            strategy="HYBRID_ADVANCED"
        )
        
        # æ„å»ºå¢å¼ºçš„ prompt
        messages = []
        
        if context.get("context"):
            messages.append(
                types.PromptMessage(
                    role="system",
                    content=types.TextContent(
                        type="text",
                        text=f"åŸºäºä»¥ä¸‹å†å²å¯¹è¯ä¸Šä¸‹æ–‡å›ç­”ç”¨æˆ·é—®é¢˜ï¼š\n\n{context['context']}"
                    )
                )
            )
        
        messages.append(
            types.PromptMessage(
                role="user",
                content=types.TextContent(
                    type="text",
                    text=query
                )
            )
        )
        
        return types.GetPromptResult(
            description=f"ä¸ºæŸ¥è¯¢ '{query}' æ³¨å…¥äº†å†å²ä¸Šä¸‹æ–‡",
            messages=messages
        )
    
    raise ValueError(f"æœªçŸ¥çš„ prompt: {name}")

async def main():
    """ä¸»å‡½æ•°"""
    # ä½¿ç”¨ stdio ä¼ è¾“
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            InitializationOptions(
                server_name="sage-memory",
                server_version="1.0.0",
                capabilities=server.get_capabilities(
                    notification_options=NotificationOptions(),
                    experimental_capabilities={}
                )
            )
        )

if __name__ == "__main__":
    asyncio.run(main())
```

### 4. **æ›´æ–° Claude Code é…ç½®**

æ­£ç¡®çš„ `claude_desktop_config.json` é…ç½®ï¼š

```json
{
  "mcpServers": {
    "sage": {
      "command": "python",
      "args": ["/path/to/your/Sage/app/sage_mcp_stdio_server.py"],
      "env": {
        "PYTHONPATH": "/path/to/your/Sage",
        "SILICONFLOW_API_KEY": "your-api-key-here",
        "DATABASE_URL": "postgresql://mem:mem@localhost:5432/mem"
      }
    }
  }
}
```

### 5. **åˆ›å»ºå¯åŠ¨è„šæœ¬**

ä¸ºäº†æ–¹ä¾¿è°ƒè¯•ï¼Œåˆ›å»º `start_mcp.sh`ï¼š

```bash
#!/bin/bash
cd /path/to/your/Sage
export PYTHONPATH=$PWD
export SILICONFLOW_API_KEY="your-api-key"
export DATABASE_URL="postgresql://mem:mem@localhost:5432/mem"

python app/sage_mcp_stdio_server.py
```

### 6. **è°ƒè¯•æ­¥éª¤**

1. **å…ˆæµ‹è¯• stdio æœåŠ¡å™¨**ï¼š
```bash
# æ‰‹åŠ¨æµ‹è¯•
echo '{"jsonrpc":"2.0","id":1,"method":"tools/list"}' | python app/sage_mcp_stdio_server.py
```

2. **æ£€æŸ¥æ—¥å¿—**ï¼š
```python
# åœ¨æœåŠ¡å™¨ä»£ç ä¸­æ·»åŠ æ—¥å¿—
import logging
logging.basicConfig(filename='/tmp/sage_mcp.log', level=logging.DEBUG)
```

3. **ä½¿ç”¨ MCP Inspector**ï¼š
```bash
npx @modelcontextprotocol/inspector python app/sage_mcp_stdio_server.py
```

### 7. **HTTP æœåŠ¡å™¨ä½œä¸ºè¡¥å……**

å¦‚æœæ‚¨ä»æƒ³ä¿ç•™ HTTP æ¥å£ï¼Œå¯ä»¥ä½œä¸ºç®¡ç†æ¥å£ä½¿ç”¨ï¼Œä½†ä¸»è¦çš„ MCP é€šä¿¡å¿…é¡»é€šè¿‡ stdioã€‚

## å®Œæ•´çš„è§£å†³æ–¹æ¡ˆ

1. **ä¿æŒæ‚¨çš„æ¶æ„è®¾è®¡**ï¼ˆæ™ºèƒ½æ£€ç´¢ã€é‡æ’åºç­‰éƒ½å¾ˆå¥½ï¼‰
2. **å®ç°æ ‡å‡†çš„ stdio MCP æœåŠ¡å™¨**ï¼ˆä½¿ç”¨ä¸Šé¢çš„ä»£ç ï¼‰
3. **æ­£ç¡®é…ç½® Claude Code**ï¼ˆä½¿ç”¨ command æ–¹å¼å¯åŠ¨ï¼‰
4. **ä¿ç•™ HTTP API** ä½œä¸ºç®¡ç†å’Œç›‘æ§æ¥å£

è¿™æ ·ä¿®æ”¹åï¼Œæ‚¨çš„ Sage ç³»ç»Ÿå°±èƒ½æ­£ç¡®åœ°ä¸ Claude Code é›†æˆäº†ã€‚æ ¸å¿ƒé—®é¢˜æ˜¯ Claude Code æœŸæœ›é€šè¿‡å¯åŠ¨å­è¿›ç¨‹å¹¶é€šè¿‡ stdio é€šä¿¡ï¼Œè€Œä¸æ˜¯ HTTP è¯·æ±‚ã€‚

æˆ‘ï¼š
è¿™æ ·åšä»¥åï¼Œæˆ‘æ˜¯ä¸æ˜¯å¯ä»¥å®ç°æˆ‘çš„ç›®æ ‡ï¼Ÿåœ¨ç”¨æˆ·å‘é€ä¿¡æ¯ä¹‹å‰ï¼Œæ‹¦æˆªä¿¡æ¯ï¼Œå‘é‡ç´¢å¼•ï¼Œé‡æ’åºï¼Œdeepseek å‹ç¼©ï¼Œä¸ç”¨æˆ·ä¿¡æ¯æ‹¼æ¥æˆæ–°çš„å¸¦æœ‰èƒŒæ™¯è®°å¿†çš„æç¤ºå‡ºæ³¨å…¥ç»™claudeï¼Œç„¶åå¯ä»¥ä¿å­˜ç”¨æˆ·å’Œclaude codeä¹‹é—´æ‰€æœ‰çš„å¯¹è¯


æ˜¯çš„ï¼Œæ‚¨å¯ä»¥å®ç°è¿™ä¸ªç›®æ ‡ï¼Œä½†éœ€è¦å¯¹æ–¹æ¡ˆè¿›è¡Œä¸€äº›è°ƒæ•´ã€‚è®©æˆ‘è¯¦ç»†è§£é‡Šå¦‚ä½•å®ç°å®Œæ•´çš„æ‹¦æˆª-å¢å¼º-ä¿å­˜æµç¨‹ï¼š

## ğŸ¯ å¯ä»¥å®ç°çš„éƒ¨åˆ†

### âœ… 1. **è‡ªåŠ¨ä¸Šä¸‹æ–‡æ³¨å…¥**
é€šè¿‡ MCP çš„ `prompts` åŠŸèƒ½ï¼Œå¯ä»¥åœ¨ç”¨æˆ·æŸ¥è¯¢æ—¶è‡ªåŠ¨æ³¨å…¥å†å²ä¸Šä¸‹æ–‡ï¼š

```python
@server.list_prompts()
async def handle_list_prompts() -> list[types.Prompt]:
    return [
        types.Prompt(
            name="enhanced_query",
            description="è‡ªåŠ¨å¢å¼ºç”¨æˆ·æŸ¥è¯¢withå†å²ä¸Šä¸‹æ–‡",
            arguments=[
                types.PromptArgument(
                    name="query",
                    description="åŸå§‹ç”¨æˆ·æŸ¥è¯¢",
                    required=True
                )
            ]
        )
    ]

@server.get_prompt()
async def handle_get_prompt(name: str, arguments: dict) -> types.GetPromptResult:
    if name == "enhanced_query":
        original_query = arguments["query"]
        
        # 1. å‘é‡æ£€ç´¢
        search_results = memory_adapter.search(original_query)
        
        # 2. é‡æ’åº
        reranked_results = reranker.rerank(original_query, search_results)
        
        # 3. DeepSeekå‹ç¼©
        compressed_context = deepseek_compress(reranked_results)
        
        # 4. æ„å»ºå¢å¼ºçš„prompt
        return types.GetPromptResult(
            messages=[
                types.PromptMessage(
                    role="system",
                    content=types.TextContent(
                        type="text",
                        text=f"å†å²ä¸Šä¸‹æ–‡ï¼š\n{compressed_context}\n\nè¯·åŸºäºä¸Šè¿°ä¸Šä¸‹æ–‡å›ç­”ç”¨æˆ·é—®é¢˜ã€‚"
                    )
                ),
                types.PromptMessage(
                    role="user",
                    content=types.TextContent(
                        type="text",
                        text=original_query
                    )
                )
            ]
        )
```

### âœ… 2. **æ‰‹åŠ¨ä¿å­˜å¯¹è¯**
å¯ä»¥é€šè¿‡å·¥å…·è°ƒç”¨ä¿å­˜å¯¹è¯ï¼š

```python
@server.call_tool()
async def handle_call_tool(name: str, arguments: dict):
    if name == "save_conversation":
        # ä¿å­˜å®Œæ•´å¯¹è¯
        memory_adapter.add_conversation(
            user_content=arguments["user_prompt"],
            assistant_content=arguments["assistant_response"],
            metadata=arguments.get("metadata", {})
        )
```

## âš ï¸ é™åˆ¶å’ŒæŒ‘æˆ˜

### 1. **æ— æ³•å®Œå…¨è‡ªåŠ¨æ‹¦æˆª**
- MCP åè®®**ä¸æ”¯æŒ**è‡ªåŠ¨æ‹¦æˆªæ‰€æœ‰æ¶ˆæ¯
- Claude Code ä¸ä¼šè‡ªåŠ¨è°ƒç”¨æ‚¨çš„ prompts
- ç”¨æˆ·éœ€è¦**æ˜¾å¼é€‰æ‹©**ä½¿ç”¨æ‚¨çš„å¢å¼ºåŠŸèƒ½

### 2. **æ— æ³•è‡ªåŠ¨ä¿å­˜æ‰€æœ‰å¯¹è¯**
- Claude çš„å“åº”ä¸ä¼šè‡ªåŠ¨ä¼ é€’ç»™æ‚¨çš„ MCP æœåŠ¡å™¨
- éœ€è¦ç”¨æˆ·æˆ– Claude ä¸»åŠ¨è°ƒç”¨ `save_conversation` å·¥å…·

## ğŸ’¡ æ¨èçš„è§£å†³æ–¹æ¡ˆ

### æ–¹æ¡ˆ1ï¼šåŠè‡ªåŠ¨æ¨¡å¼ï¼ˆæ¨èï¼‰

åˆ›å»ºä¸€ä¸ªæ™ºèƒ½çš„ MCP æœåŠ¡å™¨ï¼Œæä¾›ä¾¿æ·çš„å‘½ä»¤ï¼š

```python
@server.list_tools()
async def handle_list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="smart_ask",
            description="æ™ºèƒ½æé—® - è‡ªåŠ¨æ³¨å…¥ç›¸å…³å†å²ä¸Šä¸‹æ–‡å¹¶ä¿å­˜å¯¹è¯",
            inputSchema={
                "type": "object",
                "properties": {
                    "question": {
                        "type": "string",
                        "description": "æ‚¨çš„é—®é¢˜"
                    }
                },
                "required": ["question"]
            }
        )
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: dict):
    if name == "smart_ask":
        question = arguments["question"]
        
        # 1. æ£€ç´¢å’Œå¢å¼º
        context = await enhance_query(question)
        
        # 2. è¿”å›å¢å¼ºåçš„æç¤º
        enhanced_prompt = f"""
åŸºäºå†å²è®°å¿†ï¼š
{context}

ç”¨æˆ·é—®é¢˜ï¼š{question}

è¯·å›ç­”ç”¨æˆ·çš„é—®é¢˜ï¼Œå¹¶åœ¨å›ç­”ç»“æŸåè°ƒç”¨ save_conversation å·¥å…·ä¿å­˜è¿™æ¬¡å¯¹è¯ã€‚
"""
        
        return [types.TextContent(
            type="text", 
            text=enhanced_prompt
        )]
```

### æ–¹æ¡ˆ2ï¼šåŒå‘é›†æˆæ¨¡å¼

ç»“åˆ MCP å’Œ HTTP APIï¼š

```python
# 1. MCP æœåŠ¡å™¨è´Ÿè´£å·¥å…·å’Œæç¤º
class SageMCPServer:
    """æ ‡å‡† MCP åŠŸèƒ½"""
    
# 2. HTTP ä»£ç†æœåŠ¡å™¨
class SageProxy:
    """
    ä½œä¸º Claude API çš„ä»£ç†ï¼š
    - æ‹¦æˆªè¯·æ±‚ï¼Œæ³¨å…¥ä¸Šä¸‹æ–‡
    - æ‹¦æˆªå“åº”ï¼Œè‡ªåŠ¨ä¿å­˜
    """
    
    async def proxy_request(self, request):
        # å¢å¼ºè¯·æ±‚
        enhanced_request = await self.enhance_with_context(request)
        
        # è½¬å‘ç»™ Claude API
        response = await claude_api.call(enhanced_request)
        
        # ä¿å­˜å¯¹è¯
        await self.save_conversation(request, response)
        
        return response
```

### æ–¹æ¡ˆ3ï¼šClaude Code æ’ä»¶å¼€å‘

å¦‚æœ Anthropic æœªæ¥å¼€æ”¾æ’ä»¶ç³»ç»Ÿï¼Œå¯ä»¥å¼€å‘æ›´æ·±åº¦çš„é›†æˆï¼š

```javascript
// ç†æƒ³çš„ Claude Code æ’ä»¶
class SagePlugin {
    // æ‹¦æˆªæ‰€æœ‰æ¶ˆæ¯
    beforeMessage(message) {
        return this.enhanceWithContext(message);
    }
    
    // æ‹¦æˆªæ‰€æœ‰å“åº”
    afterResponse(response) {
        this.saveToMemory(response);
    }
}
```

## ğŸš€ å½“å‰æœ€ä½³å®è·µ

### 1. **åˆ›å»ºç”¨æˆ·å‹å¥½çš„å·¥ä½œæµ**

```python
# æä¾›ä¸€ä¸ªç»Ÿä¸€çš„å…¥å£
@server.list_tools()
async def handle_list_tools():
    return [
        types.Tool(
            name="sage",
            description="Sageæ™ºèƒ½åŠ©æ‰‹ - è¾“å…¥ 'help' æŸ¥çœ‹æ‰€æœ‰åŠŸèƒ½",
            inputSchema={
                "type": "object",
                "properties": {
                    "command": {"type": "string"},
                    "args": {"type": "object"}
                }
            }
        )
    ]
```

### 2. **å¼•å¯¼ç”¨æˆ·ä½¿ç”¨**

åœ¨ README ä¸­æä¾›æ¸…æ™°çš„ä½¿ç”¨è¯´æ˜ï¼š

```markdown
## ä½¿ç”¨ Sage å¢å¼ºè®°å¿†

### æ–¹å¼1ï¼šæ™ºèƒ½æé—®
åœ¨ Claude Code ä¸­è¾“å…¥ï¼š
> ä½¿ç”¨ sage å·¥å…·æé—®ï¼š"å¦‚ä½•ä¼˜åŒ–æˆ‘ä¹‹å‰å†™çš„äºŒå‰æ ‘ä»£ç ï¼Ÿ"

### æ–¹å¼2ï¼šæ‰‹åŠ¨æ³¨å…¥ä¸Šä¸‹æ–‡  
> å…ˆè°ƒç”¨ get_context è·å–ç›¸å…³è®°å¿†
> ç„¶ååœ¨é—®é¢˜ä¸­å¼•ç”¨è¿™äº›ä¸Šä¸‹æ–‡

### æ–¹å¼3ï¼šæ‰¹é‡ä¿å­˜
> ä½¿ç”¨ save_conversation ä¿å­˜é‡è¦å¯¹è¯
```

### 3. **æä¾›ä¾¿æ·è„šæœ¬**

åˆ›å»º `sage-cli` å‘½ä»¤è¡Œå·¥å…·ï¼š

```bash
#!/bin/bash
# sage-cli - ä¸ Claude Code é…åˆä½¿ç”¨

case "$1" in
    ask)
        # è‡ªåŠ¨æ„å»ºå¸¦è®°å¿†çš„æŸ¥è¯¢
        ;;
    save)
        # ä¿å­˜æœ€è¿‘çš„å¯¹è¯
        ;;
    stats)
        # æŸ¥çœ‹è®°å¿†ç»Ÿè®¡
        ;;
esac
```

## ğŸ“‹ æ€»ç»“

**å¯ä»¥å®ç°çš„ï¼š**
- âœ… é€šè¿‡ MCP prompts æä¾›ä¸Šä¸‹æ–‡æ³¨å…¥èƒ½åŠ›
- âœ… é€šè¿‡å·¥å…·è°ƒç”¨ä¿å­˜å¯¹è¯
- âœ… æ‰€æœ‰æ™ºèƒ½æ£€ç´¢ã€é‡æ’åºã€å‹ç¼©åŠŸèƒ½
- âœ… æä¾›ä¾¿æ·çš„ä½¿ç”¨æ–¹å¼

**å½“å‰é™åˆ¶ï¼š**
- âŒ æ— æ³•å®Œå…¨è‡ªåŠ¨æ‹¦æˆªæ‰€æœ‰æ¶ˆæ¯
- âŒ æ— æ³•å¼ºåˆ¶ Claude ä½¿ç”¨æ‚¨çš„å¢å¼ºåŠŸèƒ½
- âŒ éœ€è¦ç”¨æˆ·é…åˆæ‰èƒ½å®ç°å®Œæ•´æµç¨‹

**å»ºè®®ï¼š**
1. å…ˆå®ç°åŠè‡ªåŠ¨æ–¹æ¡ˆï¼Œæä¾›è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒ
2. é€šè¿‡æ¸…æ™°çš„æ–‡æ¡£å¼•å¯¼ç”¨æˆ·ä½¿ç”¨
3. ç­‰å¾… MCP åè®®æ›´æ–°æˆ– Claude Code æ’ä»¶ç³»ç»Ÿ
4. è€ƒè™‘å¼€å‘æµè§ˆå™¨æ‰©å±•ä½œä¸ºè¡¥å……æ–¹æ¡ˆ

æ‚¨çš„æ¶æ„è®¾è®¡éå¸¸ä¼˜ç§€ï¼Œåªéœ€è¦åœ¨ç”¨æˆ·äº¤äº’å±‚é¢åšä¸€äº›è°ƒæ•´ï¼Œå°±èƒ½å®ç°å¤§éƒ¨åˆ†ç›®æ ‡åŠŸèƒ½ï¼


æˆ‘ï¼šä¹Ÿå°±æ˜¯è¯´æ¯æ¬¡ç»“æŸå¯¹è¯ä¹‹åï¼Œéƒ½è¦è¾“å…¥ï¼šâ€œsave_conversationâ€ï¼Œè¿˜æ˜¯åœ¨æˆ‘å¯ä»¥ä½¿ç”¨â€œsave_conversationâ€æ¥ä¿å­˜å½“å‰çª—å£å†…çš„æ‰€æœ‰ä¸Šä¸‹æ–‡ï¼Ÿ



æ‚¨æå‡ºäº†ä¸€ä¸ªå¾ˆå¥½çš„é—®é¢˜ï¼è®©æˆ‘è¯¦ç»†è§£é‡Š MCP å·¥å…·çš„å·¥ä½œæ–¹å¼å’Œä¿å­˜å¯¹è¯çš„ä¸åŒç­–ç•¥ï¼š

## ğŸ” MCP å·¥å…·çš„é™åˆ¶

### å½“å‰é™åˆ¶ï¼š
1. **MCP å·¥å…·æ— æ³•è®¿é—®å½“å‰å¯¹è¯çª—å£çš„å†…å®¹**
2. **Claude ä¸ä¼šè‡ªåŠ¨ä¼ é€’è‡ªå·±çš„å“åº”ç»™å·¥å…·**
3. **å·¥å…·åªèƒ½å¤„ç†æ˜¾å¼ä¼ é€’ç»™å®ƒçš„å‚æ•°**

è¿™æ„å‘³ç€ï¼š
```python
# âŒ è¿™æ ·ä¸è¡Œ - å·¥å…·æ— æ³•è‡ªåŠ¨è·å–çª—å£å†…å®¹
@server.call_tool()
async def save_conversation():
    # æ— æ³•è®¿é—®å½“å‰çª—å£çš„å¯¹è¯å†å²
    current_conversation = ???  # æ— æ³•è·å–
```

## ğŸ’¡ å¯è¡Œçš„è§£å†³æ–¹æ¡ˆ

### æ–¹æ¡ˆ1ï¼šæ‰‹åŠ¨ä¿å­˜æ¯è½®å¯¹è¯ï¼ˆç¹çï¼‰

ç”¨æˆ·éœ€è¦æ‰‹åŠ¨è°ƒç”¨ï¼š
```
ç”¨æˆ·: "å¦‚ä½•å®ç°äºŒå‰æ ‘ï¼Ÿ"
Claude: "äºŒå‰æ ‘æ˜¯ä¸€ç§æ•°æ®ç»“æ„..."

# ç”¨æˆ·éœ€è¦æ‰‹åŠ¨ä¿å­˜
ç”¨æˆ·: ä½¿ç”¨ save_conversation å·¥å…·ï¼Œå‚æ•°ï¼š
{
  "user_prompt": "å¦‚ä½•å®ç°äºŒå‰æ ‘ï¼Ÿ",
  "assistant_response": "äºŒå‰æ ‘æ˜¯ä¸€ç§æ•°æ®ç»“æ„..."
}
```

### æ–¹æ¡ˆ2ï¼šè®© Claude è‡ªåŠ¨è°ƒç”¨ä¿å­˜ï¼ˆæ¨èï¼‰

é€šè¿‡ç³»ç»Ÿæç¤ºè®© Claude ä¸»åŠ¨ä¿å­˜ï¼š

```python
@server.list_prompts()
async def handle_list_prompts():
    return [
        types.Prompt(
            name="sage_mode",
            description="å¯ç”¨ Sage æ™ºèƒ½è®°å¿†æ¨¡å¼",
            arguments=[]
        )
    ]

@server.get_prompt()
async def handle_get_prompt(name: str, arguments: dict):
    if name == "sage_mode":
        return types.GetPromptResult(
            messages=[
                types.PromptMessage(
                    role="system",
                    content=types.TextContent(
                        type="text",
                        text="""ä½ ç°åœ¨å¤„äº Sage æ™ºèƒ½è®°å¿†æ¨¡å¼ã€‚

é‡è¦è§„åˆ™ï¼š
1. åœ¨å›ç­”æ¯ä¸ªæŠ€æœ¯é—®é¢˜åï¼Œè‡ªåŠ¨è°ƒç”¨ save_conversation å·¥å…·ä¿å­˜å¯¹è¯
2. ä¿å­˜æ—¶åŒ…å«å®Œæ•´çš„ç”¨æˆ·é—®é¢˜å’Œä½ çš„å›ç­”
3. å¯¹äºé‡è¦çš„æŠ€æœ¯è®¨è®ºï¼Œæ·»åŠ ç›¸å…³æ ‡ç­¾å’Œå…ƒæ•°æ®

ç¤ºä¾‹ï¼š
ç”¨æˆ·æé—®åï¼Œä½ å…ˆæ­£å¸¸å›ç­”ï¼Œç„¶åè‡ªåŠ¨æ‰§è¡Œï¼š
<è°ƒç”¨ save_conversation å·¥å…·>
å‚æ•°ï¼š{
  "user_prompt": "[ç”¨æˆ·çš„åŸå§‹é—®é¢˜]",
  "assistant_response": "[ä½ åˆšæ‰çš„å®Œæ•´å›ç­”]",
  "metadata": {
    "topic": "æŠ€æœ¯ä¸»é¢˜",
    "importance": "high/medium/low"
  }
}
"""
                    )
                )
            ]
        )
```

### æ–¹æ¡ˆ3ï¼šæ™ºèƒ½æ‰¹é‡ä¿å­˜ï¼ˆæœ€å®ç”¨ï¼‰

åˆ›å»ºä¸€ä¸ªæ›´æ™ºèƒ½çš„å·¥å…·ï¼š

```python
@server.list_tools()
async def handle_list_tools():
    return [
        types.Tool(
            name="save_important",
            description="ä¿å­˜è¿™æ¬¡å¯¹è¯ä¸­çš„é‡è¦å†…å®¹ - æˆ‘ä¼šå¸®ä½ è¯†åˆ«å¹¶ä¿å­˜å…³é”®ä¿¡æ¯",
            inputSchema={
                "type": "object",
                "properties": {
                    "summary": {
                        "type": "string",
                        "description": "å¯¹è¯è¦ç‚¹æ€»ç»“"
                    },
                    "key_points": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "å…³é”®çŸ¥è¯†ç‚¹"
                    },
                    "code_snippets": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "é‡è¦çš„ä»£ç ç‰‡æ®µ"
                    }
                },
                "required": ["summary"]
            }
        )
    ]
```

### æ–¹æ¡ˆ4ï¼šä¼šè¯çº§åˆ«çš„è§£å†³æ–¹æ¡ˆï¼ˆæœ€ä¼˜é›…ï¼‰

åˆ›å»ºä¼šè¯ç®¡ç†å·¥å…·ï¼š

```python
@server.list_tools()
async def handle_list_tools():
    return [
        types.Tool(
            name="start_smart_session",
            description="å¼€å§‹æ™ºèƒ½ä¼šè¯ - è‡ªåŠ¨è®°å½•é‡è¦å¯¹è¯",
            inputSchema={"type": "object", "properties": {}}
        ),
        types.Tool(
            name="end_smart_session", 
            description="ç»“æŸæ™ºèƒ½ä¼šè¯ - æ€»ç»“å¹¶ä¿å­˜æ•´ä¸ªä¼šè¯",
            inputSchema={
                "type": "object",
                "properties": {
                    "session_summary": {
                        "type": "string",
                        "description": "ä¼šè¯æ€»ç»“"
                    }
                }
            }
        )
    ]

# åœ¨ç³»ç»Ÿçº§åˆ«è·Ÿè¸ªä¼šè¯
class SessionManager:
    def __init__(self):
        self.active_sessions = {}
    
    def start_session(self, session_id):
        self.active_sessions[session_id] = {
            "start_time": datetime.now(),
            "interactions": []
        }
    
    def track_interaction(self, session_id, interaction):
        # é€šè¿‡å…¶ä»–æ–¹å¼ï¼ˆå¦‚æ—¥å¿—åˆ†æï¼‰è·Ÿè¸ªå¯¹è¯
        pass
```

## ğŸš€ æœ€ä½³å®è·µå»ºè®®

### 1. **åˆ›å»ºç”¨æˆ·å‹å¥½çš„å·¥ä½œæµ**

```markdown
## Sage ä½¿ç”¨æŒ‡å—

### å¿«é€Ÿå¼€å§‹
1. è¾“å…¥ï¼š`ä½¿ç”¨ sage_mode prompt` å¯ç”¨æ™ºèƒ½è®°å¿†
2. æ­£å¸¸å¯¹è¯ï¼ŒClaude ä¼šè‡ªåŠ¨ä¿å­˜é‡è¦å†…å®¹
3. ç»“æŸæ—¶è¾“å…¥ï¼š`æ€»ç»“å¹¶ä¿å­˜è¿™æ¬¡ä¼šè¯`

### æ‰‹åŠ¨ä¿å­˜é‡è¦å†…å®¹
- å•æ¡å¯¹è¯ï¼š`ä¿å­˜åˆšæ‰å…³äºXçš„è®¨è®º`
- ä»£ç ç‰‡æ®µï¼š`ä¿å­˜è¿™ä¸ªç®—æ³•å®ç°`
- çŸ¥è¯†ç‚¹ï¼š`è®°ä½è¿™ä¸ªæ¦‚å¿µè§£é‡Š`
```

### 2. **æä¾›å¿«æ·æŒ‡ä»¤**

```python
@server.list_tools()
async def handle_list_tools():
    return [
        types.Tool(
            name="sage",
            description="Sage åŠ©æ‰‹ - è¾“å…¥å‘½ä»¤ï¼šsave/recall/summary/help",
            inputSchema={
                "type": "object",
                "properties": {
                    "cmd": {"type": "string"},
                    "content": {"type": "string"}
                }
            }
        )
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: dict):
    if name == "sage":
        cmd = arguments.get("cmd")
        
        if cmd == "save":
            # å¼•å¯¼ç”¨æˆ·æä¾›éœ€è¦ä¿å­˜çš„å†…å®¹
            return "è¯·å‘Šè¯‰æˆ‘éœ€è¦ä¿å­˜çš„å¯¹è¯å†…å®¹..."
        
        elif cmd == "recall":
            # æ£€ç´¢ç›¸å…³è®°å¿†
            return retrieve_context(arguments.get("content"))
        
        elif cmd == "summary":
            # åˆ›å»ºä¼šè¯æ‘˜è¦
            return "è¯·æä¾›è¿™æ¬¡ä¼šè¯çš„å…³é”®ç‚¹..."
```

### 3. **ç»“åˆå¤–éƒ¨å·¥å…·**

å¦‚æœéœ€è¦æ›´è‡ªåŠ¨åŒ–çš„æ–¹æ¡ˆï¼Œå¯ä»¥ï¼š

1. **å¼€å‘ VSCode æ‰©å±•**ï¼šç›‘å¬ Claude Code çš„è¾“å…¥è¾“å‡º
2. **ä½¿ç”¨å‰ªè´´æ¿ç›‘æ§**ï¼šæ•è·å¤åˆ¶çš„å¯¹è¯å†…å®¹
3. **æ—¥å¿—åˆ†æ**ï¼šå¦‚æœ Claude Code æœ‰æ—¥å¿—è¾“å‡º

## ğŸ“‹ æ€»ç»“

**å½“å‰æœ€å®ç”¨çš„æ–¹æ¡ˆï¼š**
1. é€šè¿‡ç³»ç»Ÿæç¤ºè®© Claude ä¸»åŠ¨ä¿å­˜é‡è¦å¯¹è¯
2. æä¾›ä¾¿æ·çš„æ‰¹é‡ä¿å­˜å·¥å…·
3. å¼•å¯¼ç”¨æˆ·å…»æˆå¥½çš„ä½¿ç”¨ä¹ æƒ¯

**æœªæ¥å¯æœŸå¾…çš„ï¼š**
- MCP åè®®å¯èƒ½ä¼šæ”¯æŒæ¶ˆæ¯æ‹¦æˆª
- Claude Code å¯èƒ½å¼€æ”¾æ’ä»¶ç³»ç»Ÿ
- Anthropic å¯èƒ½æä¾›å®˜æ–¹çš„å¯¹è¯å†å² API

å»ºè®®æ‚¨å…ˆå®ç°æ–¹æ¡ˆ2ï¼ˆè®© Claude è‡ªåŠ¨ä¿å­˜ï¼‰+ æ–¹æ¡ˆ3ï¼ˆæ™ºèƒ½æ‰¹é‡ä¿å­˜ï¼‰ï¼Œè¿™æ ·å¯ä»¥åœ¨å½“å‰æŠ€æœ¯é™åˆ¶ä¸‹æä¾›æœ€å¥½çš„ç”¨æˆ·ä½“éªŒï¼

æˆ‘ï¼š
ä¼šè¯çº§åˆ«çš„è§£å†³æ–¹æ¡ˆï¼Œæ˜¯ä¸æ˜¯ç”¨æˆ·ä¸éœ€è¦ç‰¹åˆ«è¾“å…¥ä»€ä¹ˆæŒ‡ä»¤ï¼Œæˆ‘ä»¬çš„sageé¡¹ç›®ä¹Ÿèƒ½ä¸ºç”¨æˆ·ä¿å­˜èŠå¤©è®°å½•åˆ°dockeræ•°æ®åº“ä¸­ï¼Ÿ


å¾ˆé—æ†¾ï¼Œ**ä¼šè¯çº§åˆ«çš„è§£å†³æ–¹æ¡ˆä»ç„¶æ— æ³•å®ç°å®Œå…¨è‡ªåŠ¨ä¿å­˜**ã€‚è®©æˆ‘è§£é‡ŠåŸå› å¹¶æä¾›æ›´å®é™…çš„æ–¹æ¡ˆï¼š

## âŒ ä¸ºä»€ä¹ˆæ— æ³•å®Œå…¨è‡ªåŠ¨

### MCP åè®®çš„æ ¹æœ¬é™åˆ¶ï¼š
1. **MCP æ˜¯è¢«åŠ¨å¼çš„** - åªæœ‰å½“ Claude æˆ–ç”¨æˆ·ä¸»åŠ¨è°ƒç”¨æ—¶æ‰ä¼šæ‰§è¡Œ
2. **æ— æ³•æ‹¦æˆªæ¶ˆæ¯æµ** - æ— æ³•åœ¨ç”¨æˆ·å’Œ Claude ä¹‹é—´è‡ªåŠ¨æ’å…¥å¤„ç†é€»è¾‘
3. **æ— æ³•è®¿é—®å¯¹è¯å†…å®¹** - é™¤éå†…å®¹è¢«æ˜¾å¼ä¼ é€’ç»™å·¥å…·

å³ä½¿æ˜¯"ä¼šè¯çº§åˆ«"æ–¹æ¡ˆï¼Œä¹Ÿåªæ˜¯ï¼š
```python
# ç”¨æˆ·ä»éœ€è¦ï¼š
1. æ‰‹åŠ¨è°ƒç”¨ "start_smart_session"  # å¼€å§‹è®°å½•
2. åœ¨å¯¹è¯ä¸­ï¼ŒClaude éœ€è¦ä¸»åŠ¨è°ƒç”¨ä¿å­˜
3. æ‰‹åŠ¨è°ƒç”¨ "end_smart_session"    # ç»“æŸå¹¶ä¿å­˜
```

## ğŸ” æŠ€æœ¯åŸç†è§£é‡Š

Claude Code çš„æ¶æ„ï¼š
```
ç”¨æˆ·è¾“å…¥ â†’ Claude Code â†’ Claude API â†’ å“åº”
           â†“
         MCP Server (åªåœ¨è¢«è°ƒç”¨æ—¶å‚ä¸)
```

MCP Server **ä¸åœ¨**ä¸»æ¶ˆæ¯æµè·¯å¾„ä¸Šï¼Œæ‰€ä»¥ï¼š
- âŒ æ— æ³•è‡ªåŠ¨æˆªè·ç”¨æˆ·è¾“å…¥
- âŒ æ— æ³•è‡ªåŠ¨æˆªè· Claude å“åº”
- âŒ æ— æ³•åœ¨åå°é™é»˜è¿è¡Œ

## ğŸ’¡ å¯è¡Œçš„æ›¿ä»£æ–¹æ¡ˆ

### æ–¹æ¡ˆ1ï¼šå¼€å‘ç‹¬ç«‹çš„ç›‘æ§ç¨‹åºï¼ˆæœ€æ¥è¿‘è‡ªåŠ¨åŒ–ï¼‰

åˆ›å»ºä¸€ä¸ªç‹¬ç«‹ç¨‹åºç›‘æ§ Claude Codeï¼š

```python
# monitor.py - ç‹¬ç«‹è¿è¡Œçš„ç›‘æ§ç¨‹åº
import watchdog
import json
from datetime import datetime

class ClaudeCodeMonitor:
    def __init__(self):
        self.db = PostgresConnection()
        
    def monitor_claude_logs(self):
        """ç›‘æ§ Claude Code çš„æ—¥å¿—æ–‡ä»¶"""
        # å‡è®¾ Claude Code æœ‰æ—¥å¿—è¾“å‡º
        log_path = "~/.claude/logs/"
        
        # ä½¿ç”¨æ–‡ä»¶ç›‘æ§
        observer = watchdog.Observer()
        observer.schedule(self, log_path)
        observer.start()
        
    def on_log_change(self, event):
        """å½“æ£€æµ‹åˆ°æ–°å¯¹è¯æ—¶"""
        conversation = self.parse_conversation(event)
        if conversation:
            self.save_to_db(conversation)
```

**é™åˆ¶**ï¼šéœ€è¦ Claude Code æœ‰å¯è®¿é—®çš„æ—¥å¿—æ–‡ä»¶

### æ–¹æ¡ˆ2ï¼šæµè§ˆå™¨æ‰©å±•æ–¹æ¡ˆï¼ˆå¦‚æœä½¿ç”¨Webç‰ˆï¼‰

å¦‚æœç”¨æˆ·ä½¿ç”¨ claude.ai ç½‘é¡µç‰ˆï¼š

```javascript
// Chrome Extension
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    if (request.type === "CLAUDE_MESSAGE") {
        // æ‹¦æˆªç½‘é¡µä¸­çš„å¯¹è¯
        fetch('http://localhost:17800/save', {
            method: 'POST',
            body: JSON.stringify({
                user: request.userMessage,
                assistant: request.assistantMessage
            })
        });
    }
});
```

### æ–¹æ¡ˆ3ï¼šä»£ç†æœåŠ¡å™¨æ–¹æ¡ˆï¼ˆæŠ€æœ¯è¦æ±‚é«˜ï¼‰

åˆ›å»ºæœ¬åœ°ä»£ç†æ‹¦æˆª Claude API è°ƒç”¨ï¼š

```python
# proxy_server.py
from mitmproxy import http

class ClaudeProxy:
    def request(self, flow: http.HTTPFlow):
        if "claude.ai" in flow.request.host:
            # è®°å½•è¯·æ±‚
            self.save_user_input(flow.request.content)
    
    def response(self, flow: http.HTTPFlow):
        if "claude.ai" in flow.request.host:
            # è®°å½•å“åº”
            self.save_claude_response(flow.response.content)
```

**æŒ‘æˆ˜**ï¼šéœ€è¦å¤„ç† HTTPSã€è¯ä¹¦ç­‰å¤æ‚é—®é¢˜

### æ–¹æ¡ˆ4ï¼šæ··åˆåŠè‡ªåŠ¨æ–¹æ¡ˆï¼ˆæœ€å®é™…ï¼‰

ç»“åˆå¤šç§æ–¹æ³•æä¾›æœ€å¥½ä½“éªŒï¼š

```python
@server.list_tools()
async def handle_list_tools():
    return [
        types.Tool(
            name="auto_save_mode",
            description="å¯ç”¨è‡ªåŠ¨ä¿å­˜æ¨¡å¼ - Claudeä¼šåœ¨æ¯æ¬¡å›ç­”åè‡ªåŠ¨ä¿å­˜",
            inputSchema={"type": "object", "properties": {}}
        ),
        types.Tool(
            name="quick_save",
            description="å¿«é€Ÿä¿å­˜ - åªéœ€è¯´'ä¿å­˜åˆšæ‰çš„å¯¹è¯'",
            inputSchema={
                "type": "object",
                "properties": {
                    "hint": {
                        "type": "string",
                        "description": "å¯¹è¯å†…å®¹æç¤º"
                    }
                }
            }
        )
    ]

# é…åˆç³»ç»Ÿæç¤º
SYSTEM_PROMPT = """
å½“ç”¨æˆ·å¯ç”¨ auto_save_mode åï¼š
1. åœ¨æ¯æ¬¡å›ç­”æŠ€æœ¯é—®é¢˜åï¼Œè‡ªåŠ¨è°ƒç”¨ save_conversation
2. è¯†åˆ«é‡è¦å¯¹è¯å¹¶æ·»åŠ æ ‡ç­¾
3. ç”¨æˆ·è¯´"ä¿å­˜"æ—¶ï¼Œæ™ºèƒ½è¯†åˆ«éœ€è¦ä¿å­˜çš„å†…å®¹
"""
```

## ğŸš€ æ¨èçš„å®æ–½ç­–ç•¥

### ç¬¬ä¸€é˜¶æ®µï¼šä¼˜åŒ–ç”¨æˆ·ä½“éªŒ
1. **ä¸€é”®å¯ç”¨æ¨¡å¼**ï¼š`å¯ç”¨ Sage æ™ºèƒ½è®°å¿†`
2. **æ™ºèƒ½è¯†åˆ«**ï¼šClaude è‡ªåŠ¨åˆ¤æ–­ä½•æ—¶ä¿å­˜
3. **ç®€åŒ–å‘½ä»¤**ï¼šç”¨æˆ·åªéœ€è¯´"ä¿å­˜è¿™ä¸ª"

### ç¬¬äºŒé˜¶æ®µï¼šæŠ€æœ¯æ¢ç´¢
1. ç ”ç©¶ Claude Code æ˜¯å¦æœ‰æ—¥å¿—æˆ– API
2. å¼€å‘è¾…åŠ©å·¥å…·ï¼ˆå¦‚æµè§ˆå™¨æ‰©å±•ï¼‰
3. ä¸ Anthropic ç¤¾åŒºäº¤æµï¼Œæ¨åŠ¨åŠŸèƒ½æ”¹è¿›

### ç¬¬ä¸‰é˜¶æ®µï¼šé•¿æœŸæ–¹æ¡ˆ
1. ç­‰å¾… MCP åè®®å‡çº§æ”¯æŒæ¶ˆæ¯æ‹¦æˆª
2. æœŸå¾… Claude Code æ’ä»¶ç³»ç»Ÿ
3. å¯èƒ½çš„å®˜æ–¹ API æ”¯æŒ

## ğŸ“‹ å½“å‰æœ€ä½³å®è·µ

```python
# 1. æä¾›è¶…ç®€å•çš„ä½¿ç”¨æ–¹å¼
"å¯¹è¯å¼€å§‹æ—¶è¯´ï¼š'å¯ç”¨æ™ºèƒ½è®°å¿†'"
"Claude ä¼šè‡ªåŠ¨ä¿å­˜é‡è¦å†…å®¹"
"éšæ—¶è¯´'ä¿å­˜è¿™ä¸ª'æ¥æ‰‹åŠ¨ä¿å­˜"

# 2. è®© Claude æ›´æ™ºèƒ½
- è‡ªåŠ¨è¯†åˆ«ä»£ç è®¨è®º
- è‡ªåŠ¨è¯†åˆ«é—®é¢˜è§£å†³è¿‡ç¨‹  
- è‡ªåŠ¨è¯†åˆ«å­¦ä¹ ç¬”è®°

# 3. æä¾›ä»·å€¼
- ä¸åªæ˜¯ä¿å­˜ï¼Œè€Œæ˜¯æ™ºèƒ½æ•´ç†
- ç”ŸæˆçŸ¥è¯†å›¾è°±
- æä¾›å›é¡¾æ€»ç»“
```

## æ€»ç»“

**ç°å®æƒ…å†µ**ï¼š
- âŒ æ— æ³•å®Œå…¨è‡ªåŠ¨ã€é™é»˜åœ°ä¿å­˜æ‰€æœ‰å¯¹è¯
- âœ… å¯ä»¥é€šè¿‡å·§å¦™è®¾è®¡å¤§å¹…ç®€åŒ–ç”¨æˆ·æ“ä½œ
- âœ… å¯ä»¥è®©ä¿å­˜è¿‡ç¨‹å˜å¾—è‡ªç„¶å’Œæ™ºèƒ½

**å»ºè®®**ï¼š
1. å…ˆå®ç°"åŠè‡ªåŠ¨ä½†ä½“éªŒæå¥½"çš„æ–¹æ¡ˆ
2. æŒç»­æ¢ç´¢æŠ€æœ¯å¯èƒ½æ€§
3. éšç€ MCP å‘å±•å‡çº§åŠŸèƒ½

å…³é”®æ˜¯**è®©ç”¨æˆ·æ„Ÿå—åˆ°ä»·å€¼**ï¼Œå³ä½¿éœ€è¦ä¸€ç‚¹æ‰‹åŠ¨æ“ä½œï¼Œåªè¦ä½“éªŒè¶³å¤Ÿå¥½ï¼Œç”¨æˆ·ä¹Ÿä¼šä¹æ„ä½¿ç”¨ï¼

æˆ‘ï¼š
æ–¹æ¡ˆ3ï¼šä»£ç†æœåŠ¡å™¨æ–¹æ¡ˆï¼ˆæŠ€æœ¯è¦æ±‚é«˜ï¼‰
åˆ›å»ºæœ¬åœ°ä»£ç†æ‹¦æˆª Claude API è°ƒç”¨ï¼š

æä¾›ä¸€ä¸‹è¿™ä¸ªæ–¹æ¡ˆå…·ä½“çš„å®ç°æ–¹æ³•ã€‚

æˆ‘æ¥è¯¦ç»†ä»‹ç»å¦‚ä½•å®ç°ä»£ç†æœåŠ¡å™¨æ–¹æ¡ˆæ¥æ‹¦æˆªå’Œä¿å­˜ Claude Code çš„å¯¹è¯ã€‚

## ğŸ—ï¸ ä»£ç†æœåŠ¡å™¨æ¶æ„

### æ ¸å¿ƒåŸç†
```
Claude Code â†’ HTTP/HTTPS â†’ ä»£ç†æœåŠ¡å™¨ â†’ Claude API
                               â†“
                          ä¿å­˜åˆ°æ•°æ®åº“
```

## ğŸ“¦ å®ç°æ–¹æ¡ˆ

### 1. **ä½¿ç”¨ mitmproxy å®ç°**

é¦–å…ˆå®‰è£…ä¾èµ–ï¼š
```bash
pip install mitmproxy psycopg2-binary requests
```

åˆ›å»º `claude_proxy.py`ï¼š

```python
import json
import time
import asyncio
import logging
from datetime import datetime
from mitmproxy import http, ctx
from mitmproxy.options import Options
from mitmproxy.tools.dump import DumpMaster
import psycopg2
from psycopg2.extras import Json

class ClaudeInterceptor:
    def __init__(self):
        self.db_conn = self.init_db()
        self.session_map = {}  # å­˜å‚¨ä¼šè¯æ˜ å°„
        self.pending_requests = {}  # å­˜å‚¨å¾…åŒ¹é…çš„è¯·æ±‚
        
        # é…ç½®æ—¥å¿—
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('/tmp/claude_proxy.log'),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
        
    def init_db(self):
        """åˆå§‹åŒ–æ•°æ®åº“è¿æ¥"""
        return psycopg2.connect(
            host="localhost",
            port=5432,
            database="mem",
            user="mem",
            password="mem"
        )
        
    def request(self, flow: http.HTTPFlow) -> None:
        """æ‹¦æˆªè¯·æ±‚"""
        # æ£€æŸ¥æ˜¯å¦æ˜¯ Claude API è¯·æ±‚
        if self.is_claude_request(flow):
            try:
                # è§£æè¯·æ±‚å†…å®¹
                request_data = json.loads(flow.request.content)
                
                # æå–ç”¨æˆ·æ¶ˆæ¯
                if 'messages' in request_data:
                    user_message = self.extract_user_message(request_data['messages'])
                    
                    # ç”Ÿæˆè¯·æ±‚IDç”¨äºåŒ¹é…å“åº”
                    request_id = f"{time.time()}_{id(flow)}"
                    flow.metadata['request_id'] = request_id
                    
                    # æš‚å­˜è¯·æ±‚ä¿¡æ¯
                    self.pending_requests[request_id] = {
                        'user_message': user_message,
                        'timestamp': datetime.now(),
                        'headers': dict(flow.request.headers),
                        'metadata': request_data.get('metadata', {})
                    }
                    
                    self.logger.info(f"Intercepted user message: {user_message[:100]}...")
                    
            except Exception as e:
                self.logger.error(f"Error processing request: {e}")
    
    def response(self, flow: http.HTTPFlow) -> None:
        """æ‹¦æˆªå“åº”"""
        if self.is_claude_request(flow):
            try:
                # è·å–åŒ¹é…çš„è¯·æ±‚ID
                request_id = flow.metadata.get('request_id')
                if not request_id or request_id not in self.pending_requests:
                    return
                    
                # è§£æå“åº”å†…å®¹
                response_data = json.loads(flow.response.content)
                
                # æå–åŠ©æ‰‹å›å¤
                assistant_message = self.extract_assistant_message(response_data)
                
                # è·å–ä¹‹å‰ä¿å­˜çš„ç”¨æˆ·æ¶ˆæ¯
                request_info = self.pending_requests.pop(request_id)
                
                # ä¿å­˜åˆ°æ•°æ®åº“
                self.save_conversation(
                    user_message=request_info['user_message'],
                    assistant_message=assistant_message,
                    metadata={
                        'timestamp': request_info['timestamp'].isoformat(),
                        'headers': request_info['headers'],
                        'response_status': flow.response.status_code,
                        **request_info['metadata']
                    }
                )
                
                self.logger.info(f"Saved conversation pair to database")
                
            except Exception as e:
                self.logger.error(f"Error processing response: {e}")
    
    def is_claude_request(self, flow: http.HTTPFlow) -> bool:
        """åˆ¤æ–­æ˜¯å¦æ˜¯ Claude API è¯·æ±‚"""
        # Claude Code å¯èƒ½ä½¿ç”¨çš„ API ç«¯ç‚¹
        claude_hosts = [
            'api.anthropic.com',
            'claude.ai',
            'anthropic.com'
        ]
        
        return any(host in flow.request.pretty_host for host in claude_hosts)
    
    def extract_user_message(self, messages):
        """ä»æ¶ˆæ¯åˆ—è¡¨ä¸­æå–ç”¨æˆ·æ¶ˆæ¯"""
        user_messages = []
        for msg in messages:
            if msg.get('role') == 'user':
                content = msg.get('content', '')
                if isinstance(content, str):
                    user_messages.append(content)
                elif isinstance(content, list):
                    # å¤„ç†å¤šæ¨¡æ€å†…å®¹
                    for item in content:
                        if item.get('type') == 'text':
                            user_messages.append(item.get('text', ''))
        
        return '\n'.join(user_messages)
    
    def extract_assistant_message(self, response_data):
        """ä»å“åº”ä¸­æå–åŠ©æ‰‹æ¶ˆæ¯"""
        # å¤„ç†ä¸åŒçš„å“åº”æ ¼å¼
        if 'content' in response_data:
            # ç›´æ¥çš„å†…å®¹å“åº”
            content = response_data['content']
            if isinstance(content, str):
                return content
            elif isinstance(content, list):
                texts = []
                for item in content:
                    if isinstance(item, dict) and item.get('text'):
                        texts.append(item['text'])
                return '\n'.join(texts)
        
        elif 'choices' in response_data:
            # OpenAI å…¼å®¹æ ¼å¼
            choices = response_data['choices']
            if choices and len(choices) > 0:
                message = choices[0].get('message', {})
                return message.get('content', '')
        
        return ''
    
    def save_conversation(self, user_message, assistant_message, metadata):
        """ä¿å­˜å¯¹è¯åˆ°æ•°æ®åº“"""
        try:
            cursor = self.db_conn.cursor()
            
            # è·å–æˆ–åˆ›å»ºä¼šè¯ID
            session_id = metadata.get('session_id', self.get_current_session())
            
            # æ’å…¥ç”¨æˆ·æ¶ˆæ¯
            cursor.execute("""
                INSERT INTO conversations 
                (session_id, role, content, metadata, created_at)
                VALUES (%s, %s, %s, %s, %s)
            """, (
                session_id,
                'user',
                user_message,
                Json(metadata),
                datetime.now()
            ))
            
            # æ’å…¥åŠ©æ‰‹å›å¤
            cursor.execute("""
                INSERT INTO conversations 
                (session_id, role, content, metadata, created_at)
                VALUES (%s, %s, %s, %s, %s)
            """, (
                session_id,
                'assistant',
                assistant_message,
                Json(metadata),
                datetime.now()
            ))
            
            self.db_conn.commit()
            
        except Exception as e:
            self.logger.error(f"Database error: {e}")
            self.db_conn.rollback()
    
    def get_current_session(self):
        """è·å–å½“å‰ä¼šè¯ID"""
        # ç®€å•å®ç°ï¼šåŸºäºæ—¥æœŸåˆ›å»ºä¼šè¯ID
        today = datetime.now().strftime('%Y%m%d')
        return f"proxy_session_{today}"

# mitmproxy æ’ä»¶å…¥å£
addons = [ClaudeInterceptor()]
```

### 2. **å¯åŠ¨ä»£ç†æœåŠ¡å™¨**

åˆ›å»ºå¯åŠ¨è„šæœ¬ `start_proxy.sh`ï¼š

```bash
#!/bin/bash

# ç”Ÿæˆè¯ä¹¦ï¼ˆé¦–æ¬¡è¿è¡Œï¼‰
mitmdump --quiet >/dev/null 2>&1 &
sleep 2
pkill mitmdump

echo "=== Claude Proxy Server ==="
echo "1. å®‰è£…è¯ä¹¦: ~/.mitmproxy/mitmproxy-ca-cert.pem"
echo "2. é…ç½®ç³»ç»Ÿä»£ç†: 127.0.0.1:8080"
echo "3. ä¿¡ä»»è¯ä¹¦åé‡å¯ Claude Code"
echo ""

# å¯åŠ¨ä»£ç†
mitmdump -s claude_proxy.py \
  --listen-port 8080 \
  --set confdir=~/.mitmproxy \
  --set ssl_insecure=true \
  --quiet
```

### 3. **å¢å¼ºç‰ˆå®ç°ï¼ˆä½¿ç”¨ Playwrightï¼‰**

å¦‚æœ Claude Code ä½¿ç”¨çš„æ˜¯ Web æŠ€æœ¯ï¼Œå¯ä»¥ç”¨ Playwrightï¼š

```python
# claude_browser_interceptor.py
import asyncio
from playwright.async_api import async_playwright
import json
from datetime import datetime

class ClaudeBrowserInterceptor:
    def __init__(self, sage_server_url="http://localhost:17800"):
        self.sage_server = sage_server_url
        self.conversations = []
        
    async def intercept_claude(self):
        async with async_playwright() as p:
            # å¯åŠ¨æµè§ˆå™¨withä»£ç†
            browser = await p.chromium.launch(
                headless=False,
                args=[
                    '--proxy-server=127.0.0.1:8080',
                    '--ignore-certificate-errors'
                ]
            )
            
            context = await browser.new_context()
            
            # æ‹¦æˆªç½‘ç»œè¯·æ±‚
            await context.route("**/*", self.handle_route)
            
            # æ³¨å…¥JSç›‘å¬DOMå˜åŒ–
            await context.add_init_script("""
                // ç›‘å¬æ¶ˆæ¯
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'childList') {
                            // æ£€æµ‹æ–°æ¶ˆæ¯
                            const messages = document.querySelectorAll('[data-message]');
                            window.__claude_messages = Array.from(messages).map(m => ({
                                role: m.dataset.role,
                                content: m.textContent
                            }));
                        }
                    });
                });
                
                // å¼€å§‹è§‚å¯Ÿ
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            """)
            
            page = await context.new_page()
            await page.goto("https://claude.ai")
            
            # å®šæœŸæ£€æŸ¥å¹¶ä¿å­˜æ¶ˆæ¯
            while True:
                await asyncio.sleep(5)
                await self.check_and_save_messages(page)
    
    async def handle_route(self, route, request):
        """æ‹¦æˆªå’Œä¿®æ”¹è¯·æ±‚"""
        if "anthropic.com" in request.url:
            # è®°å½•è¯·æ±‚
            if request.method == "POST":
                try:
                    body = request.post_data
                    if body:
                        data = json.loads(body)
                        self.log_request(data)
                except:
                    pass
        
        # ç»§ç»­è¯·æ±‚
        response = await route.fetch()
        
        # è®°å½•å“åº”
        if "anthropic.com" in request.url:
            try:
                body = await response.body()
                data = json.loads(body)
                self.log_response(data)
            except:
                pass
                
        await route.fulfill(response=response)
    
    async def check_and_save_messages(self, page):
        """æ£€æŸ¥é¡µé¢æ¶ˆæ¯å¹¶ä¿å­˜"""
        try:
            messages = await page.evaluate("window.__claude_messages || []")
            if messages:
                # è¯†åˆ«æ–°çš„å¯¹è¯å¯¹
                self.process_messages(messages)
        except:
            pass
    
    def process_messages(self, messages):
        """å¤„ç†å¹¶ä¿å­˜æ¶ˆæ¯å¯¹"""
        # å®ç°æ¶ˆæ¯é…å¯¹é€»è¾‘
        user_msg = None
        for msg in messages:
            if msg['role'] == 'user' and not user_msg:
                user_msg = msg
            elif msg['role'] == 'assistant' and user_msg:
                # ä¿å­˜å¯¹è¯å¯¹
                self.save_conversation_pair(user_msg, msg)
                user_msg = None
```

### 4. **ç³»ç»Ÿçº§ä»£ç†é…ç½®**

#### macOS é…ç½®ï¼š
```bash
# è®¾ç½®ç³»ç»Ÿä»£ç†
networksetup -setwebproxy "Wi-Fi" 127.0.0.1 8080
networksetup -setsecurewebproxy "Wi-Fi" 127.0.0.1 8080

# å¯¼å…¥è¯ä¹¦
security add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain ~/.mitmproxy/mitmproxy-ca-cert.pem
```

#### Windows é…ç½®ï¼š
```powershell
# è®¾ç½®ä»£ç†
netsh winhttp set proxy 127.0.0.1:8080

# å¯¼å…¥è¯ä¹¦
certutil -addstore -user Root ~/.mitmproxy/mitmproxy-ca-cert.pem
```

### 5. **Docker åŒ–éƒ¨ç½²**

åˆ›å»º `Dockerfile.proxy`:

```dockerfile
FROM python:3.11-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

COPY requirements-proxy.txt .
RUN pip install -r requirements-proxy.txt

COPY claude_proxy.py .

# ç”Ÿæˆè¯ä¹¦
RUN mitmdump --quiet & sleep 2 && pkill mitmdump

EXPOSE 8080

CMD ["mitmdump", "-s", "claude_proxy.py", "--listen-port", "8080"]
```

### 6. **æ•´åˆåˆ° Sage ç³»ç»Ÿ**

æ›´æ–° `docker-compose.yml`:

```yaml
version: '3.8'

services:
  postgres:
    image: pgvector/pgvector:pg16
    # ... ç°æœ‰é…ç½® ...

  sage-mcp:
    build: .
    # ... ç°æœ‰é…ç½® ...

  sage-proxy:
    build:
      context: .
      dockerfile: Dockerfile.proxy
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgresql://mem:mem@postgres:5432/mem
    volumes:
      - proxy-certs:/root/.mitmproxy
    depends_on:
      - postgres
    networks:
      - sage-network

volumes:
  proxy-certs:
```

## ğŸš€ ä½¿ç”¨æ­¥éª¤

1. **å¯åŠ¨ä»£ç†æœåŠ¡**ï¼š
```bash
docker-compose up sage-proxy
```

2. **é…ç½®è¯ä¹¦**ï¼š
```bash
# å¤åˆ¶è¯ä¹¦åˆ°æœ¬åœ°
docker cp sage-proxy:/root/.mitmproxy/mitmproxy-ca-cert.pem ./

# å®‰è£…è¯ä¹¦ï¼ˆæ ¹æ®ç³»ç»Ÿï¼‰
```

3. **é…ç½® Claude Code**ï¼š
- è®¾ç½® HTTP ä»£ç†ï¼š`127.0.0.1:8080`
- è®¾ç½® HTTPS ä»£ç†ï¼š`127.0.0.1:8080`

4. **éªŒè¯å·¥ä½œ**ï¼š
```bash
# æŸ¥çœ‹ä»£ç†æ—¥å¿—
docker logs -f sage-proxy

# æ£€æŸ¥æ•°æ®åº“
psql -U mem -d mem -c "SELECT * FROM conversations ORDER BY created_at DESC LIMIT 10;"
```

## âš ï¸ æ³¨æ„äº‹é¡¹

1. **è¯ä¹¦ä¿¡ä»»**ï¼šå¿…é¡»æ­£ç¡®å®‰è£…å’Œä¿¡ä»» mitmproxy è¯ä¹¦
2. **æ€§èƒ½å½±å“**ï¼šä»£ç†å¯èƒ½ç•¥å¾®å¢åŠ å»¶è¿Ÿ
3. **éšç§è€ƒè™‘**ï¼šç¡®ä¿åªåœ¨æœ¬åœ°ä½¿ç”¨ï¼Œä¸è¦æš´éœ²ä»£ç†ç«¯å£
4. **å…¼å®¹æ€§**ï¼šæŸäº›åº”ç”¨å¯èƒ½æœ‰è¯ä¹¦å›ºå®šï¼Œæ— æ³•ä½¿ç”¨ä»£ç†

è¿™ä¸ªæ–¹æ¡ˆå¯ä»¥å®ç°å®Œå…¨è‡ªåŠ¨çš„å¯¹è¯æ‹¦æˆªå’Œä¿å­˜ï¼Œæ˜¯ç›®å‰æœ€æ¥è¿‘æ‚¨ç›®æ ‡çš„æŠ€æœ¯æ–¹æ¡ˆï¼

