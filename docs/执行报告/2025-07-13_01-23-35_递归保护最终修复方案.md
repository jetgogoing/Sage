# 递归保护最终修复方案

## 任务概述

**目标**：彻底解决 Sage MCP 记忆系统的递归保护误触发问题，实现无感的对话存储体验。

**需求来源**：用户在测试记忆保存功能时，发现系统报告"检测到递归调用"，导致无法正常保存对话记录。经过深度分析，发现是环境变量污染导致的误判。

## 修改范围与文件变动

### 1. `/Volumes/1T HDD/Sage/claude_mem_v3.py`

#### 修改1：递归检测逻辑（行 72-89）
- **原因**：环境变量 `SAGE_RECURSION_GUARD` 会在 shell 中持久存在，导致递归保护误触发
- **改动**：使用命令行参数 `--sage-internal-call` 替代环境变量
```python
# 旧代码：
if os.getenv('SAGE_RECURSION_GUARD') == '1':
    print("[Sage] 检测到递归调用，直接传递给原始 Claude", file=sys.stderr)
    
# 新代码：
SAGE_INTERNAL_FLAG = '--sage-internal-call'
if SAGE_INTERNAL_FLAG in sys.argv:
    print("[Sage] 检测到内部调用，直接传递给原始 Claude", file=sys.stderr)
    sys.argv.remove(SAGE_INTERNAL_FLAG)
```

#### 修改2：_safe_subprocess_call 方法（行 502-513）
- **原因**：需要在调用 Claude 时添加内部标记而非设置环境变量
- **改动**：修改为添加命令行参数
```python
# 旧代码：
env['SAGE_RECURSION_GUARD'] = '1'

# 新代码：
if any('claude' in str(cmd) for cmd in command):
    command = command.copy()
    command.append('--sage-internal-call')
env.pop('SAGE_RECURSION_GUARD', None)  # 清理可能存在的旧环境变量
```

### 2. `/Volumes/1T HDD/Sage/claude-wrapper.sh`

#### 修改：添加环境变量清理（行 27）
- **原因**：确保每次执行前都清理可能遗留的环境变量
- **改动**：在主逻辑开始前添加清理命令
```bash
# 清理可能存在的递归保护环境变量
unset SAGE_RECURSION_GUARD
```

### 3. 用户 Shell 配置（~/.zshrc）
- **用户操作**：添加 `unset SAGE_RECURSION_GUARD` 到配置文件
- **目的**：防止环境变量在 shell 会话中持久存在

## 问题分析

### 根本原因

1. **环境变量污染**：
   - 当 `SAGE_RECURSION_GUARD=1` 被设置后，会在整个 shell 会话中持续存在
   - 即使 Python 进程结束，环境变量依然保留
   - 导致后续所有调用都被误判为递归调用

2. **设计缺陷**：
   - 环境变量是"全局状态"，容易造成状态污染
   - 缺乏自动清理机制
   - 无法精确控制作用范围

### 为什么需要递归保护？

递归保护的目的是防止无限循环：
- claude-sage 调用 claude_mem_v3.py
- claude_mem_v3.py 执行原始 claude 命令
- 如果没有保护，原始 claude 可能又被解析为 claude-sage
- 形成无限循环，导致系统资源耗尽

## 解决方案设计

### 方案对比

1. **环境变量方案**（已废弃）：
   - 优点：实现简单
   - 缺点：全局污染、难以清理、容易误判

2. **命令行参数方案**（采用）：
   - 优点：作用范围精确、自动随进程结束、不会污染环境
   - 缺点：需要修改命令行参数传递逻辑

3. **锁文件方案**（备选）：
   - 优点：可跨进程检测、支持复杂场景
   - 缺点：需要清理机制、增加复杂度

### 最终选择

采用**命令行参数方案**，原因：
- 简单可靠，不会造成环境污染
- 作用范围精确，仅对当前调用有效
- 自动管理生命周期，无需手动清理

## 测试验证

### 验证步骤

1. **重新加载 Shell 配置**：
   ```bash
   source ~/.zshrc
   ```

2. **测试记忆统计功能**：
   ```bash
   claude-sage --memory-stats
   ```

3. **测试对话保存功能**：
   ```bash
   claude-sage '测试消息'
   ```

4. **验证家庭信息存储**：
   ```bash
   claude-sage '我的家人都叫什么名字？'
   ```

### 预期结果

- 不再出现"检测到递归调用"的错误
- 对话能够正常保存到数据库
- 记忆检索功能正常工作

## 技术细节

### 命令行参数传递流程

1. 用户执行 `claude-sage "消息"`
2. claude-wrapper.sh 调用 claude_mem_v3.py
3. claude_mem_v3.py 调用原始 claude 时添加 `--sage-internal-call`
4. 如果检测到该标记，直接传递给原始 claude（移除标记）

### 关键代码逻辑

```python
# 检测是否为内部调用
if '--sage-internal-call' in sys.argv:
    sys.argv.remove('--sage-internal-call')  # 移除标记
    os.execv(original_claude, ['claude'] + sys.argv[1:])  # 直接执行原始 claude
```

## 后续建议

1. **监控**：
   - 观察系统运行情况，确保没有新的递归问题
   - 记录任何异常行为

2. **优化**：
   - 考虑将递归保护逻辑封装为独立模块
   - 添加更详细的调试日志

3. **文档**：
   - 更新安装文档，说明 shell 配置要求
   - 记录递归保护机制的设计原理

4. **长期改进**：
   - 考虑实现更智能的命令检测机制
   - 探索使用进程树分析等高级方案

## 总结

本次修复通过将环境变量机制替换为命令行参数机制，彻底解决了递归保护误触发的问题。新方案更加简洁、可靠，不会造成环境污染，确保了 Sage MCP 记忆系统的稳定运行。