# 方案一多层Hook数据捕获详细执行计划

**制定时间:** 2025-07-26 21:51:07  
**更新时间:** 2025-07-26 22:01:03  
**基于报告:** 2025-07-26_21-32-40_Sage记忆系统数据丢失问题分析与解决方案.md  
**目标:** 解决Sage记忆系统90%数据丢失问题，实现完整工具调用链捕获

## 🔄 重要更新 (2025-07-26 22:01)

**用户级配置和跨项目共享需求:**
- ✅ **Hooks配置级别:** 用户级 (~/.claude/settings.json) 
- ✅ **现有Hooks:** UserPromptSubmit + Stop hooks 已配置
- ✅ **Sage MCP:** 用户级配置，所有项目共享
- ✅ **数据库策略:** 统一存储，跨项目共享会话记录
- ✅ **安全级别:** 本地部署，个人使用，简化安全要求

## 执行概览

```
当前状态: 10%数据保存率 (只有文本交互)
目标状态: 95%数据保存率 (完整工具调用链)

执行策略: 渐进式升级，最小风险，最大兼容性
总工期: 约14-18天
关键成功指标: 零业务中断 + 95%数据完整性
```

## 修正说明

**重要更正:** 基于官方clarification，Hooks配置文件是 `settings.json` 而非 `.claude.md`

```
✅ **确认的Hooks配置路径:**
└── ~/.claude/settings.json        (用户级 - 所有项目共享)

🔍 **当前已配置的Hooks:**
- UserPromptSubmit: /Users/jet/Sage/hooks/scripts/sage_prompt_enhancer.py
- Stop: /Users/jet/Sage/hooks/scripts/sage_archiver.py

CLAUDE.md 用途: 记忆/上下文提示文件，与Hooks配置无关
```

## 总体架构设计

```
跨项目共享的用户级Hook协作机制:

PreToolUse Hook     PostToolUse Hook     Stop Hook
     ↓                    ↓                  ↓
 [工具调用前]          [工具执行后]        [会话结束]
     ↓                    ↓                  ↓
 捕获参数/上下文      捕获结果/错误      整合完整数据
     ↓                    ↓                  ↓
     └─────── 数据协作机制 ────────────────────┘
                         ↓
                用户级Sage MCP Server
                         ↓
              统一PostgreSQL + 向量化
              (所有项目共享数据库)
```

---

## 阶段一: 基础设施验证和配置优化

### 核心任务 (已调整为用户级配置)
1. **验证现有用户级hooks配置**
   - ✅ 当前状态: 已正确配置在 `~/.claude/settings.json`
   - ✅ UserPromptSubmit: `/Users/jet/Sage/hooks/scripts/sage_prompt_enhancer.py`
   - ✅ Stop: `/Users/jet/Sage/hooks/scripts/sage_archiver.py`
   - 目标: 验证两个hooks正常工作并为新hooks做准备

2. **跨项目数据共享机制优化**
   - 对现有sage_archiver.py增加项目标识能力
   - 确保所有项目共享同一个数据库实例
   - 简化安全检查，优化性能

### 具体实施步骤

#### 步骤1.1: 验证当前用户级hooks状态
```bash
# 在Claude Code中执行
/hooks
# 验证显示: UserPromptSubmit + Stop hooks
```

#### 步骤1.2: 项目标识能力增强
对现有hooks添加项目检测和标识能力:
```python
# 在sage_archiver.py中添加：
def get_project_identifier() -> str:
    """获取项目标识符"""
    cwd = os.getcwd()
    project_name = os.path.basename(cwd)
    return f"{project_name}_{hashlib.md5(cwd.encode()).hexdigest()[:8]}"

def enhance_metadata_with_project(metadata: Dict) -> Dict:
    """为元数据添加项目信息"""
    metadata['project_id'] = get_project_identifier()
    metadata['project_path'] = os.getcwd()
    return metadata
```

#### 步骤1.3: 简化安全检查
由于本地部署个人使用，简化security_utils.py:
```python
# 简化版本，移除过度的安全检查
# 保留基本的输入验证和文件路径检查
class SimplifiedSecurityUtils:
    @staticmethod
    def validate_basic_input(input_str: str, max_length: int = 100000) -> str:
        if len(input_str) > max_length:
            return input_str[:max_length]
        return input_str
```

#### 步骤1.4: 跨项目数据库连接验证
确保所有项目使用同一个Sage MCP服务器:
```bash
# 在不同项目中测试
cd /path/to/project1 && echo "test" | claude
cd /path/to/project2 && echo "test" | claude
# 验证数据都存储到同一个数据库
```

### 预期产出
- [x] 验证用户级hooks配置正常工作
- [x] 增强项目标识和跨项目数据共享能力
- [x] 简化安全检查，优化性能
- [x] 为新hooks实现做好基础准备

---

## 阶段二: Stop Hook数据提取增强

### 问题诊断
当前 `sage_archiver.py` Lines 135-136, 150-151 存在致命缺陷:

```python
# 当前有问题的代码
if isinstance(content_item, dict) and content_item.get('type') == 'text':
    text_content.append(content_item.get('text', ''))
```

**问题:** 只提取text类型，忽略tool_use、tool_result等90%的关键数据

### 改造目标
1. **扩展数据提取逻辑** - 支持完整的content类型
2. **保持向后兼容** - 现有文本提取功能不受影响
3. **增强数据结构** - 为工具调用数据预留存储结构
4. **性能优化** - 避免重复解析transcript文件

### 技术实现

#### 步骤2.1: 重构extract_last_conversation方法
```python
def extract_complete_interaction_chain(self, transcript_path: str):
    """提取完整的交互链数据"""
    user_message = None
    assistant_message = None
    tool_calls = []
    tool_results = []
    
    for line in reversed(lines):
        entry = json.loads(line)
        content_list = entry.get('message', {}).get('content', [])
        
        for content_item in content_list:
            content_type = content_item.get('type')
            
            if content_type == 'text':
                # 保存文本内容 (现有逻辑)
                text_content.append(content_item.get('text', ''))
                
            elif content_type == 'tool_use':
                # 保存工具调用信息
                tool_calls.append({
                    'name': content_item.get('name'),
                    'parameters': content_item.get('input', {}),
                    'id': content_item.get('id')
                })
                
            elif content_type == 'tool_result':
                # 保存工具执行结果
                tool_results.append({
                    'tool_use_id': content_item.get('tool_use_id'),
                    'content': content_item.get('content'),
                    'is_error': content_item.get('is_error', False)
                })
    
    return {
        'user_input': user_message,
        'assistant_response': assistant_message,
        'tool_calls': tool_calls,
        'tool_results': tool_results
    }
```

#### 步骤2.2: 扩展数据存储格式
```python
class EnhancedConversationData:
    def __init__(self):
        self.user_input: str = ""
        self.assistant_response: str = ""
        self.tool_calls: List[Dict] = []
        self.tool_results: List[Dict] = []
        self.metadata: Dict[str, Any] = {}
```

#### 步骤2.3: 增强sage_core接口兼容性
- 扩展MemoryContent接口支持工具调用数据
- 修改save_memory方法处理复杂数据结构
- 保持与现有向量化逻辑的兼容性

### 预期成果
- Stop Hook能够捕获70-80%的交互数据 (相比当前10%)
- 为PreToolUse/PostToolUse hooks提供参考实现
- 验证transcript.jsonl解析的正确性

---

## 阶段三: PreToolUse Hook实现

### 设计目标
捕获工具调用前的完整状态，为每个工具调用生成唯一追踪ID，建立调用链起点。

### 核心功能
1. **工具调用拦截**
   - 在工具执行前捕获调用参数
   - 记录调用上下文和环境状态
   - 生成unique_call_id用于链路追踪

2. **数据采集策略**
   - 轻量级数据捕获 (遵循官方轻量级原则)
   - 避免重型数据库操作
   - 使用临时文件或内存缓存共享数据

3. **性能考虑**
   - hook执行时间 < 50ms
   - 不阻塞工具正常执行
   - 错误处理不影响主流程

### 技术实现

#### 步骤3.1: 创建sage_pre_tool_capture.py脚本
```python
#!/usr/bin/env python3
"""
Sage PreToolUse Hook - 工具调用前状态捕获
"""
import json
import sys
import time
import uuid
from pathlib import Path

def main():
    # 读取hook输入
    input_data = json.loads(sys.stdin.read())
    
    # 生成唯一调用ID
    call_id = str(uuid.uuid4())
    
    # 捕获工具调用前状态
    pre_call_data = {
        'call_id': call_id,
        'session_id': input_data.get('session_id'),
        'tool_name': input_data.get('tool_name'),
        'tool_parameters': input_data.get('tool_input', {}),
        'timestamp': time.time(),
        'cwd': input_data.get('cwd'),
        'context': input_data.get('context', '')
    }
    
    # 保存到临时存储
    temp_dir = Path('/tmp/sage_hooks')
    temp_dir.mkdir(exist_ok=True)
    
    temp_file = temp_dir / f"pre_{call_id}.json"
    with open(temp_file, 'w') as f:
        json.dump(pre_call_data, f)
    
    # 输出到Claude (可选)
    print(json.dumps({
        "status": "captured",
        "call_id": call_id
    }))

if __name__ == "__main__":
    main()
```

#### 步骤3.2: 更新用户级settings.json添加PreToolUse Hook
```json
// 在 ~/.claude/settings.json 中添加：
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "/Users/jet/Sage/hooks/scripts/sage_pre_tool_capture.py"
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      // 现有配置保持不变
    ],
    "Stop": [
      // 现有配置保持不变
    ]
  }
}
```

#### 步骤3.3: 跨项目数据共享机制设计
适应用户级配置的数据共享策略:
```python
# 数据存储策略调整
class CrossProjectDataManager:
    def __init__(self):
        # 用户级临时目录，所有项目共享
        self.temp_dir = Path.home() / '.sage_hooks_temp'
        self.temp_dir.mkdir(exist_ok=True)
    
    def store_pre_call_data(self, call_data: Dict) -> str:
        # 添加项目信息到数据中
        call_data['project_id'] = self.get_current_project_id()
        call_data['project_path'] = os.getcwd()
        
        call_id = str(uuid.uuid4())
        file_path = self.temp_dir / f"pre_{call_id}.json"
        
        with open(file_path, 'w') as f:
            json.dump(call_data, f)
        
        return call_id
```
- 使用 `~/.sage_hooks_temp/` 用户级临时目录
- 数据包含项目标识信息
- 跨项目可见性和共享性

### 预期收益
- 捕获工具调用意图和参数
- 为PostToolUse hook提供关联数据
- 建立完整的工具执行生命周期追踪

---

## 阶段四: PostToolUse Hook实现

### 设计目标
捕获工具执行后的完整结果，关联PreToolUse的调用ID，完成工具调用链的闭环。

### 核心功能
1. **工具结果捕获**
   - 捕获工具执行的输出结果
   - 记录执行状态(成功/失败/超时)
   - 捕获错误信息和异常堆栈

2. **调用链关联**
   - 读取PreToolUse hook存储的unique_call_id
   - 将执行前后数据进行关联
   - 生成完整的工具调用记录

3. **特殊处理ZEN工具**
   - ZEN工具包含AI-to-AI专家分析
   - 需要特别提取AI分析结果
   - 保存thinking过程和expert insights

### 技术实现

#### 步骤4.1: 创建sage_post_tool_capture.py脚本
```python
#!/usr/bin/env python3
"""
Sage PostToolUse Hook - 工具执行后结果捕获
"""
import json
import sys
import time
from pathlib import Path

def main():
    # 读取hook输入
    input_data = json.loads(sys.stdin.read())
    
    # 查找对应的PreToolUse数据
    session_id = input_data.get('session_id')
    tool_name = input_data.get('tool_name')
    
    # 捕获工具执行后状态
    post_call_data = {
        'session_id': session_id,
        'tool_name': tool_name,
        'tool_output': input_data.get('tool_output', {}),
        'execution_time': input_data.get('execution_time_ms'),
        'is_error': input_data.get('is_error', False),
        'error_message': input_data.get('error_message', ''),
        'timestamp': time.time()
    }
    
    # 特殊处理ZEN工具
    if tool_name.startswith('mcp__zen__'):
        post_call_data['zen_analysis'] = extract_zen_analysis(input_data)
    
    # 关联PreToolUse数据
    temp_dir = Path('/tmp/sage_hooks')
    for pre_file in temp_dir.glob(f"pre_*.json"):
        try:
            with open(pre_file, 'r') as f:
                pre_data = json.load(f)
            
            if (pre_data.get('session_id') == session_id and 
                pre_data.get('tool_name') == tool_name):
                
                # 生成完整工具调用记录
                complete_record = {
                    'call_id': pre_data['call_id'],
                    'pre_call': pre_data,
                    'post_call': post_call_data
                }
                
                # 保存完整记录
                complete_file = temp_dir / f"complete_{pre_data['call_id']}.json"
                with open(complete_file, 'w') as f:
                    json.dump(complete_record, f)
                
                # 清理PreToolUse临时文件
                pre_file.unlink()
                break
                
        except Exception as e:
            continue
    
    print(json.dumps({"status": "processed"}))

def extract_zen_analysis(input_data):
    """提取ZEN工具的AI分析结果"""
    output = input_data.get('tool_output', {})
    return {
        'status': output.get('status'),
        'content': output.get('content'),
        'metadata': output.get('metadata', {}),
        'thinking_mode': output.get('thinking_mode'),
        'model_used': output.get('model_used')
    }

if __name__ == "__main__":
    main()
```

#### 步骤4.2: 增强数据结构
```python
class ToolCallRecord:
    def __init__(self):
        self.call_id: str = ""
        self.session_id: str = ""
        self.tool_name: str = ""
        self.pre_call: Dict = {}
        self.post_call: Dict = {}
        self.execution_time_ms: int = 0
        self.is_error: bool = False
        self.zen_analysis: Optional[Dict] = None
```

### 预期收益
- 完整捕获工具执行的生命周期
- 为Stop Hook提供丰富的工具调用数据
- 特别保存ZEN工具的AI分析过程

---

## 阶段五: 数据协作机制和集成整合

### 设计目标
整合PreToolUse、PostToolUse、Stop三层hooks的数据，实现完整的交互链重构和存储。

### 核心挑战 (跨项目共享环境)
1. **跨项目数据时序同步**
   - 确保Pre/Post/Stop hooks数据的正确关联
   - 处理不同项目并发工具调用的数据隔离
   - 基于项目标识和session_id的数据关联

2. **跨项目数据聚合策略**
   - 将分散的hook数据按项目合并为完整记录
   - 建立项目维度的工具调用与文本交互映射
   - 统一数据库中的多项目数据管理

### 技术实现

#### 步骤5.1: 跨项目数据汇聚层设计
```python
class CrossProjectHookDataAggregator:
    def __init__(self):
        self.temp_dir = Path.home() / '.sage_hooks_temp'
        
    def aggregate_session_data(self, session_id: str, project_id: str = None) -> Dict:
        """聚合会话的完整数据，支持项目筛选"""
        tool_records = []
        
        for complete_file in self.temp_dir.glob(f"complete_*.json"):
            with open(complete_file, 'r') as f:
                record = json.load(f)
                pre_call = record.get('pre_call', {})
                
                # 检查session_id匹配
                if pre_call.get('session_id') == session_id:
                    # 如果指定了project_id，进一步筛选
                    if project_id is None or pre_call.get('project_id') == project_id:
                        tool_records.append(record)
        
        # 按时间排序
        tool_records.sort(key=lambda x: x['pre_call']['timestamp'])
        
        return {
            'session_id': session_id,
            'project_id': project_id,
            'tool_call_chain': tool_records,
            'total_tools': len(tool_records),
            'aggregated_at': time.time()
        }
    
    def get_all_projects_in_session(self, session_id: str) -> List[str]:
        """获取某个会话中涉及的所有项目"""
        projects = set()
        for complete_file in self.temp_dir.glob(f"complete_*.json"):
            with open(complete_file, 'r') as f:
                record = json.load(f)
                pre_call = record.get('pre_call', {})
                if pre_call.get('session_id') == session_id:
                    projects.add(pre_call.get('project_id', 'unknown'))
        return list(projects)
```

#### 步骤5.2: 增强跨项目Stop Hook功能
```python
# 在sage_archiver.py中集成跨项目工具调用数据
def enhance_conversation_with_cross_project_tools(self, session_id: str, 
                                                conversation_data: Dict) -> Dict:
    """使用跨项目工具调用数据增强对话记录"""
    aggregator = CrossProjectHookDataAggregator()
    current_project_id = self.get_current_project_id()
    
    # 获取当前项目的工具调用数据
    tool_data = aggregator.aggregate_session_data(session_id, current_project_id)
    
    # 获取跨项目信息（可选）
    all_projects = aggregator.get_all_projects_in_session(session_id)
    
    # 合并数据
    enhanced_data = {
        **conversation_data,
        'tool_call_chain': tool_data.get('tool_call_chain', []),
        'metadata': {
            **conversation_data.get('metadata', {}),
            'project_id': current_project_id,
            'tool_calls_count': tool_data.get('total_tools', 0),
            'cross_project_session': len(all_projects) > 1,
            'session_projects': all_projects,
            'data_completeness': self.calculate_completeness(conversation_data, tool_data)
        }
    }
    
    return enhanced_data

def get_current_project_id(self) -> str:
    """获取当前项目标识符"""
    cwd = os.getcwd()
    project_name = os.path.basename(cwd)
    return f"{project_name}_{hashlib.md5(cwd.encode()).hexdigest()[:8]}"
```

#### 步骤5.3: 存储层适配
```python
# 扩展MemoryContent接口
class EnhancedMemoryContent(MemoryContent):
    def __init__(self, user_input: str, assistant_response: str, 
                 tool_call_chain: List[Dict] = None, **kwargs):
        super().__init__(user_input, assistant_response, **kwargs)
        self.tool_call_chain = tool_call_chain or []
        
    def to_vectorizable_text(self) -> str:
        """生成用于向量化的文本"""
        # 基础文本
        base_text = f"{self.user_input}\n{self.assistant_response}"
        
        # 工具调用摘要
        tool_summary = []
        for tool in self.tool_call_chain:
            tool_name = tool.get('pre_call', {}).get('tool_name', 'unknown')
            tool_summary.append(f"Tool: {tool_name}")
        
        if tool_summary:
            base_text += f"\nTools used: {', '.join(tool_summary)}"
            
        return base_text
```

### 预期效果
- 实现95%数据完整性目标
- 建立可扩展的hooks数据处理架构
- 为未来hooks功能扩展奠定基础

---

## 阶段六: 集成测试和性能优化

### 测试策略

#### 功能完整性测试
1. **端到端工具调用链数据捕获测试**
   ```bash
   # 测试用例1: 简单工具调用
   测试场景: Read -> Edit -> Bash序列
   验证点: 每个工具的Pre/Post数据完整性
   
   # 测试用例2: ZEN工具复杂分析
   测试场景: /zen:debug + /zen:thinkdeep调用
   验证点: AI分析过程的完整记录
   
   # 测试用例3: 错误处理
   测试场景: 工具执行失败场景
   验证点: 错误信息和堆栈的正确捕获
   ```

2. **数据完整性验证**
   ```python
   def verify_data_completeness(session_id: str) -> float:
       """计算数据完整性百分比"""
       transcript_tools = count_tools_in_transcript(session_id)
       captured_tools = count_captured_tools(session_id)
       return (captured_tools / transcript_tools) * 100 if transcript_tools > 0 else 0
   ```

#### 性能基准测试
1. **Hook执行时间验证**
   - 目标: 单个hook < 100ms
   - 测试: 连续1000次工具调用的性能统计

2. **并发处理能力**
   - 场景: 同时多个工具调用
   - 验证: 数据隔离和性能影响

#### 兼容性测试
1. **现有功能回归测试**
   - 验证RAG流程不受影响
   - 确认UserPromptSubmit hook正常工作
   - 检查数据库存储功能

2. **不同工具类型兼容性**
   - 测试所有常用工具(Read, Write, Bash, Glob, Grep等)
   - 验证ZEN工具特殊处理逻辑
   - 确认第三方工具的hooks支持

### 优化重点

#### 性能优化
1. **Hooks脚本执行效率**
   - 减少文件I/O操作
   - 优化JSON序列化性能
   - 使用内存缓存减少磁盘访问

2. **临时数据管理**
   ```python
   def cleanup_expired_temp_files():
       """清理过期的临时文件"""
       temp_dir = Path('/tmp/sage_hooks')
       cutoff_time = time.time() - 86400  # 24小时
       
       for temp_file in temp_dir.glob('*.json'):
           if temp_file.stat().st_mtime < cutoff_time:
               temp_file.unlink()
   ```

#### 可靠性增强
1. **错误恢复机制**
   - Hook执行失败的重试逻辑
   - 数据损坏的恢复策略
   - 优雅降级处理

2. **监控和告警**
   ```python
   class HookMonitor:
       def __init__(self):
           self.metrics = {
               'hook_executions': 0,
               'hook_failures': 0,
               'average_execution_time': 0,
               'data_completeness_rate': 0
           }
       
       def record_execution(self, hook_type: str, execution_time: float, success: bool):
           """记录hook执行指标"""
           self.metrics['hook_executions'] += 1
           if not success:
               self.metrics['hook_failures'] += 1
   ```

### 成功标准
- 数据捕获率 >= 95%
- Hook执行延迟 < 100ms
- 零功能回归问题
- 系统稳定运行72小时

---

## 阶段七: 生产部署和监控体系

### 部署策略

#### 渐进式发布
1. **阶段性启用**
   ```
   第1天: 启用基础配置 + Stop Hook增强
   第2天: 启用PreToolUse Hook
   第3天: 启用PostToolUse Hook
   第4天: 启用完整数据协作机制
   ```

2. **快速回退机制**
   ```bash
   # 紧急回退脚本
   #!/bin/bash
   # rollback_hooks.sh
   
   # 备份当前配置
   cp .claude/settings.json .claude/settings.json.backup
   
   # 恢复到基础配置
   cp .claude/settings.json.safe .claude/settings.json
   
   # 重启相关服务
   echo "Hooks rolled back to safe configuration"
   ```

#### 配置管理
1. **版本控制**
   - 所有hooks配置纳入Git版本控制
   - 使用语义化版本号标记配置变更
   - 建立配置变更审批流程

2. **文档化**
   ```markdown
   # Hooks配置说明
   
   ## 文件位置
   - 主配置: .claude/settings.json
   - 备份配置: .claude/settings.json.safe
   
   ## Hook脚本
   - PreToolUse: hooks/scripts/sage_pre_tool_capture.py
   - PostToolUse: hooks/scripts/sage_post_tool_capture.py
   - Stop: hooks/scripts/sage_archiver.py
   
   ## 故障排除
   1. 检查hooks注册状态: `/hooks`
   2. 查看执行日志: hooks/logs/
   3. 验证临时文件: /tmp/sage_hooks/
   ```

### 监控体系建设

#### 性能监控
```python
class HookPerformanceMonitor:
    def __init__(self):
        self.metrics_file = Path('hooks/logs/performance_metrics.json')
    
    def record_metrics(self):
        """记录性能指标"""
        metrics = {
            'timestamp': time.time(),
            'hook_execution_times': self.get_execution_times(),
            'data_completeness_rate': self.calculate_completeness(),
            'storage_usage': self.get_storage_usage(),
            'error_rate': self.calculate_error_rate()
        }
        
        with open(self.metrics_file, 'a') as f:
            f.write(json.dumps(metrics) + '\n')
```

#### 业务监控
1. **数据完整性监控**
   - 实时计算数据捕获率
   - 工具调用链完整性检查
   - ZEN工具分析质量评估

2. **用户体验监控**
   - Hook执行对响应时间的影响
   - 工具调用成功率统计
   - 错误恢复效果评估

#### 告警机制
```python
class HookAlertManager:
    def __init__(self):
        self.alert_thresholds = {
            'data_completeness_rate': 0.90,  # 90%以下告警
            'hook_execution_time': 0.1,      # 100ms以上告警
            'error_rate': 0.05               # 5%以上告警
        }
    
    def check_and_alert(self, metrics: Dict):
        """检查指标并发送告警"""
        for metric, threshold in self.alert_thresholds.items():
            if metrics.get(metric, 0) < threshold:
                self.send_alert(metric, metrics[metric], threshold)
```

### 运维规范

#### 日常维护
1. **文件清理**
   ```bash
   # 定期清理脚本 (daily_cleanup.sh)
   #!/bin/bash
   
   # 清理过期临时文件
   find /tmp/sage_hooks -name "*.json" -mtime +1 -delete
   
   # 轮转日志文件
   find hooks/logs -name "*.log" -size +100M -exec gzip {} \;
   
   # 清理老旧备份
   find hooks/logs/backup -name "*.json" -mtime +30 -delete
   ```

2. **配置备份**
   ```bash
   # 配置备份脚本 (backup_config.sh)
   #!/bin/bash
   
   DATE=$(date +%Y%m%d_%H%M%S)
   BACKUP_DIR="hooks/config_backups"
   
   mkdir -p $BACKUP_DIR
   cp .claude/settings.json $BACKUP_DIR/settings_$DATE.json
   cp -r hooks/scripts $BACKUP_DIR/scripts_$DATE/
   ```

#### 故障恢复
1. **诊断流程**
   ```bash
   # 故障诊断检查清单
   1. 检查hooks注册状态: /hooks
   2. 查看最近错误日志: tail -f hooks/logs/archiver.log
   3. 验证临时文件状态: ls -la /tmp/sage_hooks/
   4. 检查数据库连接: 测试sage_core功能
   5. 验证配置文件语法: python -m json.tool .claude/settings.json
   ```

2. **数据恢复**
   ```python
   def recover_lost_data(session_id: str, backup_path: str):
       """从备份恢复丢失的数据"""
       # 从backup文件恢复基础对话数据
       # 重新处理transcript.jsonl提取工具调用
       # 补充向量化和存储
   ```

### 持续改进

#### 数据分析
1. **效果评估**
   - 每周数据捕获效果分析
   - 用户反馈收集和分析
   - 性能趋势监控

2. **优化识别**
   ```python
   def analyze_hook_performance():
       """分析hook性能数据，识别优化机会"""
       # 分析执行时间分布
       # 识别性能瓶颈
       # 评估资源使用效率
   ```

#### 功能演进
1. **基于使用情况优化**
   - 根据工具使用频率调整hook优先级
   - 优化常用工具的数据捕获逻辑
   - 扩展特殊工具的支持

2. **与官方更新同步**
   - 跟踪Claude Code官方hooks功能更新
   - 适配新的hook类型和功能
   - 保持与最佳实践的一致性

### 最终目标达成

#### 核心指标
- **数据完整性:** 从10%提升至95%
- **系统稳定性:** 99.9%可用性
- **用户体验:** 零感知的功能增强
- **可维护性:** 完善的监控和运维体系

#### 长期价值
- **知识积累:** 完整的开发调试历史
- **效率提升:** 基于历史经验的智能提示
- **质量保障:** 全面的错误模式识别
- **团队协作:** 共享的技术知识库

---

## 风险管理和应急预案

### 主要风险点

#### 技术风险
1. **Hooks执行失败**
   - 风险: Hook脚本异常导致工具调用中断
   - 缓解: 完善错误处理，确保主流程不受影响
   - 应急: 快速禁用有问题的hook

2. **数据存储异常**
   - 风险: PostgreSQL连接问题或存储空间不足
   - 缓解: 连接池管理和存储监控
   - 应急: 降级到本地文件存储

#### 性能风险
1. **Hook执行延迟**
   - 风险: Hook处理时间过长影响用户体验
   - 缓解: 异步处理和性能监控
   - 应急: 临时禁用性能影响大的hook

2. **资源消耗过高**
   - 风险: 临时文件积累或内存泄漏
   - 缓解: 定期清理和资源监控
   - 应急: 重启相关服务

#### 兼容性风险
1. **Claude Code更新**
   - 风险: 官方更新破坏现有hooks
   - 缓解: 跟踪官方更新和兼容性测试
   - 应急: 版本回退和配置调整

### 应急响应流程

```
故障发生
    ↓
快速评估影响范围
    ↓
是否影响核心功能？
    ↓               ↓
   是              否
    ↓               ↓
执行紧急回退      记录问题并计划修复
    ↓               ↓
恢复基础功能      正常流程修复
    ↓               ↓
    └─── 问题分析和改进 ───┘
```

---

## 总结

本执行计划通过7个阶段的渐进式实施，将彻底解决Sage记忆系统90%数据丢失的问题。关键成功因素包括:

1. **严格遵循官方标准** - 使用settings.json配置，确保与Claude Code深度集成
2. **渐进式风险控制** - 每阶段验证，最小化对现有功能的影响
3. **完整的监控体系** - 实时跟踪数据完整性和系统性能
4. **可靠的运维流程** - 标准化的维护和应急响应机制

执行完成后，Sage将从"丢失90%价值信息"的状态转变为"完整保存开发知识资产"的强大记忆系统，为开发效率提升奠定坚实基础。

---

## 🔧 用户级配置实施补充

### A. 现状确认
✅ **已确认配置状态:**
- 用户级hooks配置: `~/.claude/settings.json`
- 现有UserPromptSubmit + Stop hooks运行正常
- Sage MCP server用户级部署，跨项目共享
- PostgreSQL数据库统一存储，所有项目共享

### B. 配置最终标准化

#### B.1 完整的 ~/.claude/settings.json 配置
```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "/Users/jet/Sage/hooks/scripts/sage_pre_tool_capture.py"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": ".*", 
        "hooks": [
          {
            "type": "command",
            "command": "/Users/jet/Sage/hooks/scripts/sage_post_tool_capture.py"
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command", 
            "command": "/Users/jet/Sage/hooks/scripts/sage_prompt_enhancer.py"
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": ".*",
        "hooks": [
          {
            "type": "command",
            "command": "/Users/jet/Sage/hooks/scripts/sage_archiver.py"
          }
        ]
      }
    ]
  },
  "mcp": {
    "servers": {
      "sage": {
        "command": "/Users/jet/Sage/start_sage_mcp.sh",
        "args": [],
        "env": {}
      }
    }
  }
}
```

#### B.2 跨项目数据路径标准化
```bash
# 创建用户级目录结构
mkdir -p ~/.sage_hooks_temp          # 跨项目临时数据交换
mkdir -p ~/.sage_config              # 用户级配置目录
mkdir -p ~/Sage/hooks/logs          # 统一日志目录 (已存在)

# 数据库路径 (通过Sage MCP配置)
SAGE_DB_PATH="/Users/jet/Sage/data/sage_memory.db"
```

#### B.3 简化安全配置 (本地部署优化)
```python
# /Users/jet/Sage/hooks/security_utils.py 简化版
class SimplifiedSecurityUtils:
    @staticmethod
    def validate_basic_input(input_str: str, max_length: int = 100000) -> str:
        """简化的输入验证 - 本地部署友好"""
        if len(input_str) > max_length:
            return input_str[:max_length]
        return input_str
    
    @staticmethod
    def get_project_id(cwd: str = None) -> str:
        """获取项目唯一标识"""
        import os, hashlib
        cwd = cwd or os.getcwd()
        project_name = os.path.basename(cwd)
        return f"{project_name}_{hashlib.md5(cwd.encode()).hexdigest()[:8]}"
```

### C. 立即可执行的下一步操作

#### C.1 阶段一优先任务
```bash
# 1. 验证当前hooks状态
claude /hooks

# 2. 测试跨项目数据共享
cd /Users/jet/TestProject1 && echo "test project 1" | claude
cd /Users/jet/TestProject2 && echo "test project 2" | claude

# 3. 检查数据是否正确分项目保存
psql -d sage_memory -c "SELECT DISTINCT metadata->>'project_id' FROM memories ORDER BY created_at DESC LIMIT 10;"
```

#### C.2 Stop Hook数据提取增强 (关键修复)
修复 `/Users/jet/Sage/hooks/scripts/sage_archiver.py` 135-136行的数据丢失问题:

```python
# 当前问题代码 (135-136行):
if isinstance(content_item, dict) and content_item.get('type') == 'text':
    text_content.append(content_item.get('text', ''))

# 修复后代码:
if isinstance(content_item, dict):
    content_type = content_item.get('type')
    if content_type == 'text':
        text_content.append(content_item.get('text', ''))
    elif content_type == 'tool_use':
        # 保存工具调用信息
        tool_calls.append({
            'name': content_item.get('name'),
            'input': content_item.get('input', {}),
            'id': content_item.get('id')
        })
    elif content_type == 'tool_result':
        # 保存工具执行结果
        tool_results.append({
            'tool_use_id': content_item.get('tool_use_id'),
            'content': content_item.get('content'),
            'is_error': content_item.get('is_error', False)
        })
```

#### C.3 项目标识增强
在现有hooks中添加项目识别能力:

```python
# 在 sage_archiver.py 的 call_sage_save 方法中添加:
def enhance_metadata_with_project(self, metadata: Dict) -> Dict:
    """为元数据添加项目信息"""
    import os, hashlib
    cwd = os.getcwd()
    project_name = os.path.basename(cwd)
    project_id = f"{project_name}_{hashlib.md5(cwd.encode()).hexdigest()[:8]}"
    
    metadata['project_id'] = project_id
    metadata['project_name'] = project_name
    metadata['project_path'] = cwd
    return metadata
```

### D. 成功验证指标

完成上述配置后的验证清单:
- [ ] **跨项目数据共享**: 不同项目目录中的Claude交互都保存到同一数据库
- [ ] **项目数据隔离**: 数据包含正确的project_id标识
- [ ] **hooks正常触发**: 在任意项目中都能看到hooks执行日志
- [ ] **数据完整性提升**: 从当前10%提升到初步70%以上

这样，基于用户级配置的跨项目共享Sage Hooks系统就可以开始初步运行和验证了。