# Sage MCP 连接问题诊断报告

**报告时间**: 2025-07-14 23:01:10  
**任务概述**: 诊断 Sage MCP 无法在 Claude Code 中连接成功的问题  
**问题来源**: 用户反馈 Sage MCP 始终无法在 Claude Code 列表中显示  

## 1. 问题分析总结

### 1.1 主要问题识别

经过深入分析 Claude Opus 4 的建议文档以及项目源代码，发现以下核心问题：

1. **MCP 配置方式错误**
   - 用户可能使用了 HTTP 方式配置：`{"type": "http", "url": "http://localhost:17800/mcp"}`
   - 但 MCP 协议标准要求使用 stdio 传输方式
   - 正确配置应该是：`{"command": "python", "args": ["path/to/script.py"]}`

2. **架构设计过于复杂**
   - 当前架构：`stdio wrapper -> HTTP server -> memory system`
   - 标准 MCP 实现：`stdio transport -> MCP server -> business logic`
   - 多层包装增加了故障点和复杂性

3. **stdio 包装器实现问题**
   - `sage_mcp_stdio.py` 的实现存在潜在问题
   - 启动时需要依赖 HTTP 服务器，增加了依赖复杂性
   - 错误处理和协议转换可能存在缺陷

### 1.2 拦截注入功能评估

项目中实现了完整的自动拦截注入系统：

**优点**：
- 设计了 `AutoMemoryInjector` 自动记忆注入器
- 实现了 `AutoContextPrompt` 自动上下文提示
- 尝试在每个请求中自动注入相关记忆

**问题**：
- 这种完全自动化的实现不符合 MCP 协议标准
- MCP 协议本身不支持完全的消息拦截
- 可能导致 Claude Code 无法正确识别和连接

## 2. 具体技术问题

### 2.1 MCP 协议兼容性问题

```python
# 当前实现 (sage_mcp_stdio.py)
async def send_request(method: str, params: Dict[str, Any] = None, id: str = None):
    """Send request to HTTP MCP server"""
    request = {
        "jsonrpc": "2.0",
        "method": method,
        "params": params or {},
    }
    # 通过 HTTP 转发到本地服务器
    async with aiohttp.ClientSession() as session:
        async with session.post(MCP_SERVER_URL, json=request) as response:
            return await response.json()
```

**问题**：
- Claude Code 期望直接的 stdio 通信
- 当前实现增加了不必要的 HTTP 层
- 可能导致协议不兼容或性能问题

### 2.2 自动注入功能的协议冲突

```python
# sage_mcp_interceptor.py
async def intercept_and_inject(self, request: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """拦截所有请求并自动注入相关记忆"""
    # 这种实现方式不符合 MCP 标准
    if GLOBAL_AUTO_INJECTION_CONFIG.get("enabled"):
        # 尝试在每个请求中注入上下文
        context = await self._get_relevant_context(query)
```

**问题**：
- MCP 协议不支持这种请求拦截机制
- 可能导致 Claude Code 无法正确解析响应
- 违反了 MCP 协议的工具调用模式

## 3. 解决方案建议

### 3.1 立即解决方案：标准 MCP 实现

基于 Claude Opus 4 的建议，重新实现标准的 MCP 服务器：

```python
# 建议的新实现：sage_mcp_stdio_server.py
from mcp.server import Server, NotificationOptions
from mcp.server.models import InitializationOptions
import mcp.server.stdio
import mcp.types as types

server = Server("sage-memory")

@server.list_tools()
async def handle_list_tools() -> list[types.Tool]:
    return [
        types.Tool(
            name="save_conversation",
            description="保存对话到记忆系统",
            inputSchema={
                "type": "object",
                "properties": {
                    "user_prompt": {"type": "string"},
                    "assistant_response": {"type": "string"},
                },
                "required": ["user_prompt", "assistant_response"]
            }
        ),
        types.Tool(
            name="get_context",
            description="获取相关历史上下文",
            inputSchema={
                "type": "object",
                "properties": {
                    "query": {"type": "string"},
                    "max_results": {"type": "integer", "default": 5}
                },
                "required": ["query"]
            }
        )
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: dict) -> list[types.TextContent]:
    if name == "save_conversation":
        # 保存对话逻辑
        success = memory_adapter.add_conversation(
            user_content=arguments["user_prompt"],
            assistant_content=arguments["assistant_response"]
        )
        return [types.TextContent(type="text", text=f"对话已保存")]
    elif name == "get_context":
        # 获取上下文逻辑
        context = retrieval_engine.retrieve_contextual(
            query=arguments["query"],
            max_results=arguments.get("max_results", 5)
        )
        return [types.TextContent(type="text", text=context)]

async def main():
    async with mcp.server.stdio.stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            InitializationOptions(
                server_name="sage-memory",
                server_version="1.0.0"
            )
        )
```

**正确的 Claude Code 配置**：

```json
{
  "mcpServers": {
    "sage": {
      "command": "python",
      "args": ["/absolute/path/to/sage_mcp_stdio_server.py"],
      "env": {
        "PYTHONPATH": "/absolute/path/to/sage",
        "SILICONFLOW_API_KEY": "your-api-key",
        "DATABASE_URL": "postgresql://mem:mem@localhost:5432/mem"
      }
    }
  }
}
```

### 3.2 中期解决方案：半自动记忆系统

由于 MCP 协议限制，实现半自动的记忆系统：

```python
@server.list_tools()
async def handle_list_tools():
    return [
        types.Tool(
            name="smart_ask",
            description="智能提问 - 自动注入相关历史上下文",
            inputSchema={
                "type": "object",
                "properties": {
                    "question": {"type": "string"}
                },
                "required": ["question"]
            }
        )
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: dict):
    if name == "smart_ask":
        question = arguments["question"]
        
        # 1. 检索和增强
        context = await enhance_query(question)
        
        # 2. 返回增强后的提示
        enhanced_prompt = f"""
基于历史记忆：
{context}

用户问题：{question}

请回答用户的问题，并在回答结束后调用 save_conversation 工具保存这次对话。
"""
        return [types.TextContent(type="text", text=enhanced_prompt)]
```

### 3.3 长期解决方案：代理服务器方案

如果用户坚持要求完全自动化，可以实现 Claude Opus 4 建议的代理服务器方案：

```python
# claude_proxy.py - 使用 mitmproxy 实现完全自动拦截
from mitmproxy import http
import json

class ClaudeInterceptor:
    def __init__(self):
        self.db_conn = self.init_db()
    
    def request(self, flow: http.HTTPFlow) -> None:
        """拦截请求并注入上下文"""
        if self.is_claude_request(flow):
            request_data = json.loads(flow.request.content)
            if 'messages' in request_data:
                user_message = self.extract_user_message(request_data['messages'])
                # 注入相关上下文
                context = self.get_relevant_context(user_message)
                if context:
                    request_data['messages'] = self.inject_context(request_data['messages'], context)
                    flow.request.content = json.dumps(request_data).encode()
    
    def response(self, flow: http.HTTPFlow) -> None:
        """拦截响应并保存对话"""
        if self.is_claude_request(flow):
            response_data = json.loads(flow.response.content)
            assistant_message = self.extract_assistant_message(response_data)
            # 自动保存对话
            self.save_conversation(user_message, assistant_message)
```

**启动代理服务器**：
```bash
mitmdump -s claude_proxy.py --listen-port 8080
```

**配置系统代理**：
```bash
# macOS
networksetup -setwebproxy "Wi-Fi" 127.0.0.1 8080
networksetup -setsecurewebproxy "Wi-Fi" 127.0.0.1 8080
```

## 4. 推荐行动计划

### 4.1 立即行动 (1-2天)

1. **重新实现 MCP 服务器**
   - 创建标准的 stdio MCP 服务器
   - 移除 HTTP 层和复杂的包装器
   - 使用官方 MCP SDK

2. **更新 Claude Code 配置**
   - 使用正确的 command 配置方式
   - 确保环境变量正确设置
   - 使用绝对路径

3. **测试连接**
   - 使用 MCP Inspector 工具测试
   - 验证 Claude Code 能正确识别

### 4.2 短期优化 (1周)

1. **优化用户体验**
   - 实现 `smart_ask` 工具简化使用
   - 提供清晰的使用指南
   - 添加自动保存提示

2. **增强稳定性**
   - 添加重试机制
   - 改善错误处理
   - 增加日志记录

### 4.3 长期规划 (1个月)

1. **探索代理服务器方案**
   - 实现完全自动化的拦截
   - 处理证书和安全问题
   - 提供一键安装脚本

2. **等待 MCP 协议升级**
   - 关注 MCP 协议的消息拦截支持
   - 准备迁移到官方解决方案

## 5. 风险评估

### 5.1 技术风险

- **代理服务器方案**：需要处理 HTTPS 证书、系统代理配置
- **MCP 协议变化**：未来版本可能需要适配
- **性能影响**：代理可能略微增加延迟

### 5.2 用户体验风险

- **配置复杂性**：代理服务器需要用户配置证书
- **兼容性问题**：某些系统可能不支持代理
- **学习成本**：用户需要适应半自动模式

## 6. 总结

Sage MCP 项目的连接问题主要源于：
1. 不符合 MCP 协议标准的实现方式
2. 过于复杂的架构设计
3. 完全自动化需求与 MCP 协议限制的冲突

**建议优先采用标准 MCP 实现方案**，这样可以确保与 Claude Code 的兼容性。对于完全自动化需求，可以考虑代理服务器方案作为补充。

项目的核心记忆系统设计是优秀的，问题主要在于与 MCP 协议的集成方式。通过重新实现 MCP 接口，可以充分发挥项目的技术优势。

---

**报告生成**: 基于 Claude Opus 4 建议文档和项目源代码分析  
**下一步**: 实施标准 MCP 服务器重构并测试连接